{
  "version": 3,
  "sources": ["../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/iterators/async.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/iterators/nodeStream.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/iterators/promise.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/iterators/reader.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/responseIterator.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/errors/index.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/parseAndCheckHttpResponse.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/serializeFetchParameter.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/selectHttpOptionsAndBody.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/checkFetcher.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/createSignalIfSupported.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/selectURI.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/rewriteURIForGET.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/createHttpLink.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/link/http/HttpLink.ts", "../../.pnpm/@wry+equality@0.5.7/node_modules/@wry/equality/src/index.ts", "../../.pnpm/optimism@0.17.5/node_modules/optimism/src/cache.ts", "../../.pnpm/@wry+context@0.7.4/node_modules/@wry/context/src/slot.ts", "../../.pnpm/@wry+context@0.7.4/node_modules/@wry/context/src/index.ts", "../../.pnpm/optimism@0.17.5/node_modules/optimism/src/context.ts", "../../.pnpm/optimism@0.17.5/node_modules/optimism/src/helpers.ts", "../../.pnpm/optimism@0.17.5/node_modules/optimism/src/entry.ts", "../../.pnpm/optimism@0.17.5/node_modules/optimism/src/dep.ts", "../../.pnpm/optimism@0.17.5/node_modules/optimism/src/index.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/core/cache.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/core/types/Cache.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/core/types/common.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/helpers.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/entityStore.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/object-canon.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/readFromStore.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/reactiveVars.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/key-extractor.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/policies.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/writeToStore.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/inMemoryCache.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/cache/inmemory/fragmentRegistry.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/networkStatus.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/equalByQuery.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/ObservableQuery.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/LocalState.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/QueryInfo.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/QueryManager.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/ApolloClient.ts", "../../.pnpm/graphql-tag@2.12.6_graphql@16.8.1/node_modules/graphql-tag/src/index.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/core/index.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/context/ApolloConsumer.tsx", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/context/ApolloContext.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/context/ApolloProvider.tsx", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useApolloClient.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useLazyQuery.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useQuery.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/parser/index.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useMutation.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useSubscription.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useReactiveVar.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useFragment.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useSuspenseQuery.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/useDeepMemo.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/useIsomorphicLayoutEffect.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/internal/__use.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/cache/QueryReference.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/cache/SuspenseCache.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/cache/getSuspenseCache.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/constants.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useBackgroundQuery.ts", "../../.pnpm/@apollo+client@3.8.6_graphql@16.8.1_react-dom@18.2.0_react@18.2.0/node_modules/@apollo/src/react/hooks/useReadQuery.ts"],
  "sourcesContent": ["/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/async.ts\n */\n\nexport default function asyncIterator<T>(\n  source: AsyncIterableIterator<T>\n): AsyncIterableIterator<T> {\n  const iterator = source[Symbol.asyncIterator]();\n  return {\n    next(): Promise<IteratorResult<T, boolean>> {\n      return iterator.next();\n    },\n    [Symbol.asyncIterator](): AsyncIterableIterator<T> {\n      return this;\n    },\n  };\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void,\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length)\n        return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/promise.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface PromiseIterator<T> {\n  next(): Promise<IteratorResult<T, ArrayBuffer | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function promiseIterator<T = ArrayBuffer>(\n  promise: Promise<ArrayBuffer>\n): AsyncIterableIterator<T> {\n  let resolved = false;\n\n  const iterator: PromiseIterator<T> = {\n    next(): Promise<IteratorResult<T, ArrayBuffer | undefined>> {\n      if (resolved)\n        return Promise.resolve({\n          value: undefined,\n          done: true,\n        });\n      resolved = true;\n      return new Promise(function (resolve, reject) {\n        promise\n          .then(function (value) {\n            resolve({ value: value as unknown as T, done: false });\n          })\n          .catch(reject);\n      });\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/reader.ts\n */\n\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\n\ninterface ReaderIterator<T> {\n  next(): Promise<ReadableStreamReadResult<T>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function readerIterator<T>(\n  reader: ReadableStreamDefaultReader<T>\n): AsyncIterableIterator<T> {\n  const iterator: ReaderIterator<T> = {\n    next() {\n      return reader.read();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n", "/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/index.ts\n */\n\nimport type { Response as NodeResponse } from \"node-fetch\";\nimport type { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../utilities/index.js\";\n\nimport asyncIterator from \"./iterators/async.js\";\nimport nodeStreamIterator from \"./iterators/nodeStream.js\";\nimport promiseIterator from \"./iterators/promise.js\";\nimport readerIterator from \"./iterators/reader.js\";\n\nfunction isNodeResponse(value: any): value is NodeResponse {\n  return !!(value as NodeResponse).body;\n}\n\nfunction isReadableStream(value: any): value is ReadableStream<any> {\n  return !!(value as ReadableStream<any>).getReader;\n}\n\nfunction isAsyncIterableIterator(\n  value: any\n): value is AsyncIterableIterator<any> {\n  return !!(\n    canUseAsyncIteratorSymbol &&\n    (value as AsyncIterableIterator<any>)[Symbol.asyncIterator]\n  );\n}\n\nfunction isStreamableBlob(value: any): value is Blob {\n  return !!(value as Blob).stream;\n}\n\nfunction isBlob(value: any): value is Blob {\n  return !!(value as Blob).arrayBuffer;\n}\n\nfunction isNodeReadableStream(value: any): value is NodeReadableStream {\n  return !!(value as NodeReadableStream).pipe;\n}\n\nexport function responseIterator<T>(\n  response: Response | NodeResponse\n): AsyncIterableIterator<T> {\n  let body: unknown = response;\n\n  if (isNodeResponse(response)) body = response.body;\n\n  if (isAsyncIterableIterator(body)) return asyncIterator<T>(body);\n\n  if (isReadableStream(body)) return readerIterator<T>(body.getReader());\n\n  // this errors without casting to ReadableStream<T>\n  // because Blob.stream() returns a NodeJS ReadableStream\n  if (isStreamableBlob(body)) {\n    return readerIterator<T>(\n      (body.stream() as unknown as ReadableStream<T>).getReader()\n    );\n  }\n\n  if (isBlob(body)) return promiseIterator<T>(body.arrayBuffer());\n\n  if (isNodeReadableStream(body)) return nodeStreamIterator<T>(body);\n\n  throw new Error(\n    \"Unknown body type for responseIterator. Please pass a streamable response.\"\n  );\n}\n", "import \"../utilities/globals/index.js\";\n\nimport type { GraphQLError, GraphQLErrorExtensions } from \"graphql\";\n\nimport { isNonNullObject } from \"../utilities/index.js\";\nimport type { ServerParseError } from \"../link/http/index.js\";\nimport type { ServerError } from \"../link/utils/index.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\n\n// This Symbol allows us to pass transport-specific errors from the link chain\n// into QueryManager/client internals without risking a naming collision within\n// extensions (which implementers can use as they see fit).\nexport const PROTOCOL_ERRORS_SYMBOL: unique symbol = Symbol();\n\ntype FetchResultWithSymbolExtensions<T> = FetchResult<T> & {\n  extensions: Record<string | symbol, any>;\n};\n\nexport interface ApolloErrorOptions {\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  protocolErrors?: ReadonlyArray<{\n    message: string;\n    extensions?: GraphQLErrorExtensions[];\n  }>;\n  clientErrors?: ReadonlyArray<Error>;\n  networkError?: Error | ServerParseError | ServerError | null;\n  errorMessage?: string;\n  extraInfo?: any;\n}\n\nexport function graphQLResultHasProtocolErrors<T>(\n  result: FetchResult<T>\n): result is FetchResultWithSymbolExtensions<T> {\n  if (result.extensions) {\n    return Array.isArray(\n      (result as FetchResultWithSymbolExtensions<T>).extensions[\n        PROTOCOL_ERRORS_SYMBOL\n      ]\n    );\n  }\n  return false;\n}\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty(\"graphQLErrors\");\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  const errors = [\n    ...err.graphQLErrors,\n    ...err.clientErrors,\n    ...err.protocolErrors,\n  ];\n  if (err.networkError) errors.push(err.networkError);\n  return (\n    errors\n      // The rest of the code sometimes unsafely types non-Error objects as GraphQLErrors\n      .map(\n        (err) =>\n          (isNonNullObject(err) && err.message) || \"Error message not found.\"\n      )\n      .join(\"\\n\")\n  );\n};\n\nexport type GraphQLErrors = ReadonlyArray<GraphQLError>;\n\nexport type NetworkError = Error | ServerParseError | ServerError | null;\n\nexport class ApolloError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLErrors;\n  public protocolErrors: ReadonlyArray<{\n    message: string;\n    extensions?: GraphQLErrorExtensions[];\n  }>;\n  public clientErrors: ReadonlyArray<Error>;\n  public networkError: Error | ServerParseError | ServerError | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    protocolErrors,\n    clientErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: ApolloErrorOptions) {\n    super(errorMessage);\n    this.name = \"ApolloError\";\n    this.graphQLErrors = graphQLErrors || [];\n    this.protocolErrors = protocolErrors || [];\n    this.clientErrors = clientErrors || [];\n    this.networkError = networkError || null;\n    this.message = errorMessage || generateErrorMessage(this);\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n", "import { responseIterator } from \"./responseIterator.js\";\nimport type { Operation } from \"../core/index.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nimport type { SubscriptionObserver } from \"zen-observable-ts\";\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>,\n>(response: Response, nextValue: (value: T) => void) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal = contentType?.includes(delimiter)\n    ? contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  const boundary = `\\r\\n--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    const searchFrom = buffer.length - boundary.length + 1;\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary, searchFrom);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      const i = message.indexOf(\"\\r\\n\\r\\n\");\n      const headers = parseHeaders(message.slice(0, i));\n      const contentType = headers[\"content-type\"];\n      if (\n        contentType &&\n        contentType.toLowerCase().indexOf(\"application/json\") === -1\n      ) {\n        throw new Error(\n          \"Unsupported patch content type: application/json is required.\"\n        );\n      }\n      // nb: Technically you'd want to slice off the beginning \"\\r\\n\" but since\n      // this is going to be `JSON.parse`d there is no need.\n      const body = message.slice(i);\n\n      if (body) {\n        const result = parseJsonBody<T>(response, body);\n        if (\n          Object.keys(result).length > 1 ||\n          \"data\" in result ||\n          \"incremental\" in result ||\n          \"errors\" in result ||\n          \"payload\" in result\n        ) {\n          if (isApolloPayloadResult(result)) {\n            let next = {};\n            if (\"payload\" in result) {\n              next = { ...result.payload };\n            }\n            if (\"errors\" in result) {\n              next = {\n                ...next,\n                extensions: {\n                  ...(\"extensions\" in next ? next.extensions : (null as any)),\n                  [PROTOCOL_ERRORS_SYMBOL]: result.errors,\n                },\n              };\n            }\n            nextValue(next as T);\n          } else {\n            // for the last chunk with only `hasNext: false`\n            // we don't need to call observer.next as there is no data/errors\n            nextValue(result);\n          }\n        } else if (\n          // If the chunk contains only a \"hasNext: false\", we can call\n          // observer.complete() immediately.\n          Object.keys(result).length === 1 &&\n          \"hasNext\" in result &&\n          !result.hasNext\n        ) {\n          return;\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = (): Record<string, unknown> | string => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: SubscriptionObserver<any>) {\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next(err.result);\n  }\n\n  observer.error(err);\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (response.status >= 300) {\n          // Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`\n          );\n        }\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map((op) => op.operationName)\n                : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\nimport type { InvariantError } from \"../../utilities/globals/index.js\";\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport const serializeFetchParameter = (p: any, label: string) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = newInvariantError(\n      `Network request failed. %s is not serializable: %s`,\n      label,\n      e.message\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n", "import type { ASTNode } from \"graphql\";\nimport { print } from \"../../utilities/index.js\";\n\nimport type { Operation } from \"../core/index.js\";\n\nexport interface Printer {\n  (node: ASTNode, originalPrint: typeof print): string;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: WindowOrWorkerGlobalScope[\"fetch\"];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * If set to true, header names won't be automatically normalized to\n   * lowercase. This allows for non-http-spec-compliant servers that might\n   * expect capitalized header names.\n   */\n  preserveHeaderCase?: boolean;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n\n  /**\n   * If set to true, use the HTTP GET method for query operations. Mutations\n   * will still use the method specified in fetchOptions.method (which defaults\n   * to POST).\n   */\n  useGETForQueries?: boolean;\n\n  /**\n   * If set to true, the default behavior of stripping unused variables\n   * from the request will be disabled.\n   *\n   * Unused variables are likely to trigger server-side validation errors,\n   * per https://spec.graphql.org/draft/#sec-All-Variables-Used, but this\n   * includeUnusedVariables option can be useful if your server deviates\n   * from the GraphQL specification by not strictly enforcing that rule.\n   */\n  includeUnusedVariables?: boolean;\n  /**\n   * A function to substitute for the default query print function. Can be\n   * used to apply changes to the results of the print function.\n   */\n  print?: Printer;\n}\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n  preserveHeaderCase?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: Record<string, string>;\n  credentials?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n  preserveHeaderCase: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: \"*/*\",\n  // The content-type header describes the type of the body of the request, and\n  // so it typically only is sent with requests that actually have bodies. One\n  // could imagine that Apollo Client would remove this header when constructing\n  // a GET request (which has no body), but we historically have not done that.\n  // This means that browsers will preflight all Apollo Client requests (even\n  // GET requests). Apollo Server's CSRF prevention feature (introduced in\n  // AS3.7) takes advantage of this fact and does not block requests with this\n  // header. If you want to drop this header from GET requests, then you should\n  // probably replace it with a `apollo-require-preflight` header, or servers\n  // with CSRF prevention enabled might block your GET request. See\n  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf\n  // for more details.\n  \"content-type\": \"application/json\",\n};\n\nconst defaultOptions = {\n  method: \"POST\",\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const defaultPrinter: Printer = (ast, printer) => printer(ast);\n\nexport function selectHttpOptionsAndBody(\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) {\n  configs.unshift(fallbackConfig);\n  return selectHttpOptionsAndBodyInternal(\n    operation,\n    defaultPrinter,\n    ...configs\n  );\n}\n\nexport function selectHttpOptionsAndBodyInternal(\n  operation: Operation,\n  printer: Printer,\n  ...configs: HttpConfig[]\n) {\n  let options = {} as HttpConfig & Record<string, any>;\n  let http = {} as HttpQueryOptions;\n\n  configs.forEach((config) => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n\n    if (config.credentials) {\n      options.credentials = config.credentials;\n    }\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  if (options.headers) {\n    options.headers = removeDuplicateHeaders(\n      options.headers,\n      http.preserveHeaderCase\n    );\n  }\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = printer(query, print);\n\n  return {\n    options,\n    body,\n  };\n}\n\n// Remove potential duplicate header names, preserving last (by insertion order).\n// This is done to prevent unintentionally duplicating a header instead of\n// overwriting it (See #8447 and #8449).\nfunction removeDuplicateHeaders(\n  headers: Record<string, string>,\n  preserveHeaderCase: boolean | undefined\n): typeof headers {\n  // If we're not preserving the case, just remove duplicates w/ normalization.\n  if (!preserveHeaderCase) {\n    const normalizedHeaders = Object.create(null);\n    Object.keys(Object(headers)).forEach((name) => {\n      normalizedHeaders[name.toLowerCase()] = headers[name];\n    });\n    return normalizedHeaders;\n  }\n\n  // If we are preserving the case, remove duplicates w/ normalization,\n  // preserving the original name.\n  // This allows for non-http-spec-compliant servers that expect intentionally\n  // capitalized header names (See #6741).\n  const headerData = Object.create(null);\n  Object.keys(Object(headers)).forEach((name) => {\n    headerData[name.toLowerCase()] = {\n      originalName: name,\n      value: headers[name],\n    };\n  });\n\n  const normalizedHeaders = Object.create(null);\n  Object.keys(headerData).forEach((name) => {\n    normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n  });\n  return normalizedHeaders;\n}\n", "import { newInvariantError } from \"../../utilities/globals/index.js\";\n\nexport const checkFetcher = (\n  fetcher: WindowOrWorkerGlobalScope[\"fetch\"] | undefined\n) => {\n  if (!fetcher && typeof fetch === \"undefined\") {\n    throw newInvariantError(`\n\"fetch\" has not been found globally and no fetcher has been \\\nconfigured. To fix this, install a fetch package (like \\\nhttps://www.npmjs.com/package/cross-fetch), instantiate the \\\nfetcher, and pass it into your HttpLink constructor. For example:\n\nimport fetch from 'cross-fetch';\nimport { ApolloClient, HttpLink } from '@apollo/client';\nconst client = new ApolloClient({\n  link: new HttpLink({ uri: '/graphql', fetch })\n});\n    `);\n  }\n};\n", "/**\n * @deprecated\n * This is not used internally any more and will be removed in\n * the next major version of Apollo Client.\n */\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === \"undefined\")\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n", "import type { Operation } from \"../core/index.js\";\n\nexport const selectURI = (\n  operation: Operation,\n  fallbackURI?: string | ((operation: Operation) => string)\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === \"function\") {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || \"/graphql\";\n  }\n};\n", "import { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport type { Body } from \"./selectHttpOptionsAndBody.js\";\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nexport function rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams: string[] = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if (\"query\" in body) {\n    addQueryParam(\"query\", body.query!);\n  }\n  if (body.operationName) {\n    addQueryParam(\"operationName\", body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        \"Variables map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"variables\", serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        \"Extensions map\"\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam(\"extensions\", serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = \"\",\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf(\"#\");\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf(\"?\") === -1 ? \"?\" : \"&\";\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join(\"&\") + fragment;\n  return { newURI };\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type { DefinitionNode } from \"graphql\";\n\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable, hasDirectives } from \"../../utilities/index.js\";\nimport { serializeFetchParameter } from \"./serializeFetchParameter.js\";\nimport { selectURI } from \"./selectURI.js\";\nimport {\n  handleError,\n  readMultipartBody,\n  parseAndCheckHttpResponse,\n} from \"./parseAndCheckHttpResponse.js\";\nimport { checkFetcher } from \"./checkFetcher.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport {\n  selectHttpOptionsAndBodyInternal,\n  defaultPrinter,\n  fallbackHttpConfig,\n} from \"./selectHttpOptionsAndBody.js\";\nimport { rewriteURIForGET } from \"./rewriteURIForGET.js\";\nimport { fromError, filterOperationVariables } from \"../utils/index.js\";\nimport {\n  maybe,\n  getMainDefinition,\n  removeClientSetsFromDocument,\n} from \"../../utilities/index.js\";\n\nconst backupFetch = maybe(() => fetch);\n\nexport const createHttpLink = (linkOptions: HttpOptions = {}) => {\n  let {\n    uri = \"/graphql\",\n    // use default global fetch if nothing passed in\n    fetch: preferredFetch,\n    print = defaultPrinter,\n    includeExtensions,\n    preserveHeaderCase,\n    useGETForQueries,\n    includeUnusedVariables = false,\n    ...requestOptions\n  } = linkOptions;\n\n  if (__DEV__) {\n    // Make sure at least one of preferredFetch, window.fetch, or backupFetch is\n    // defined, so requests won't fail at runtime.\n    checkFetcher(preferredFetch || backupFetch);\n  }\n\n  const linkConfig = {\n    http: { includeExtensions, preserveHeaderCase },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink((operation) => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders: {\n      \"apollographql-client-name\"?: string;\n      \"apollographql-client-version\"?: string;\n    } = {};\n\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders[\"apollographql-client-name\"] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders[\"apollographql-client-version\"] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    if (hasDirectives([\"client\"], operation.query)) {\n      const transformedQuery = removeClientSetsFromDocument(operation.query);\n\n      if (!transformedQuery) {\n        return fromError(\n          new Error(\n            \"HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`.\"\n          )\n        );\n      }\n\n      operation.query = transformedQuery;\n    }\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBodyInternal(\n      operation,\n      print,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig\n    );\n\n    if (body.variables && !includeUnusedVariables) {\n      body.variables = filterOperationVariables(\n        body.variables,\n        operation.query\n      );\n    }\n\n    let controller: AbortController | undefined;\n    if (!options.signal && typeof AbortController !== \"undefined\") {\n      controller = new AbortController();\n      options.signal = controller.signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"mutation\";\n    };\n    const definitionIsSubscription = (d: DefinitionNode) => {\n      return d.kind === \"OperationDefinition\" && d.operation === \"subscription\";\n    };\n    const isSubscription = definitionIsSubscription(\n      getMainDefinition(operation.query)\n    );\n    // does not match custom directives beginning with @defer\n    const hasDefer = hasDirectives([\"defer\"], operation.query);\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = \"GET\";\n    }\n\n    if (hasDefer || isSubscription) {\n      options.headers = options.headers || {};\n      let acceptHeader = \"multipart/mixed;\";\n      // Omit defer-specific headers if the user attempts to defer a selection\n      // set on a subscription and log a warning.\n      if (isSubscription && hasDefer) {\n        invariant.warn(\"Multipart-subscriptions do not support @defer\");\n      }\n\n      if (isSubscription) {\n        acceptHeader +=\n          \"boundary=graphql;subscriptionSpec=1.0,application/json\";\n      } else if (hasDefer) {\n        acceptHeader += \"deferSpec=20220824,application/json\";\n      }\n      options.headers.accept = acceptHeader;\n    }\n\n    if (options.method === \"GET\") {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, \"Payload\");\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable((observer) => {\n      // Prefer linkOptions.fetch (preferredFetch) if provided, and otherwise\n      // fall back to the *current* global window.fetch function (see issue\n      // #7832), or (if all else fails) the backupFetch function we saved when\n      // this module was first evaluated. This last option protects against the\n      // removal of window.fetch, which is unlikely but not impossible.\n      const currentFetch = preferredFetch || maybe(() => fetch) || backupFetch;\n\n      const observerNext = observer.next.bind(observer);\n      currentFetch!(chosenURI, options)\n        .then((response) => {\n          operation.setContext({ response });\n          const ctype = response.headers?.get(\"content-type\");\n\n          if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n            return readMultipartBody(response, observerNext);\n          } else {\n            return parseAndCheckHttpResponse(operation)(response).then(\n              observerNext\n            );\n          }\n        })\n        .then(() => {\n          controller = undefined;\n          observer.complete();\n        })\n        .catch((err) => {\n          controller = undefined;\n          handleError(err, observer);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n", "import type { RequestHandler } from \"../core/index.js\";\nimport { ApolloLink } from \"../core/index.js\";\nimport type { HttpOptions } from \"./selectHttpOptionsAndBody.js\";\nimport { createHttpLink } from \"./createHttpLink.js\";\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(public options: HttpOptions = {}) {\n    super(createHttpLink(options).request);\n  }\n}\n", "const { toString, hasOwnProperty } = Object.prototype;\nconst fnToStr = Function.prototype.toString;\nconst previousComparisons = new Map<object, Set<object>>();\n\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a: any, b: any): boolean {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\n// Allow default imports as well.\nexport default equal;\n\nfunction check(a: any, b: any): boolean {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n      // Fall through to object case...\n    case '[object Object]': {\n      if (previouslyCompared(a, b)) return true;\n\n      const aKeys = definedKeys(a);\n      const bKeys = definedKeys(b);\n\n      // If `a` and `b` have a different number of enumerable keys, they\n      // must be different.\n      const keyCount = aKeys.length;\n      if (keyCount !== bKeys.length) return false;\n\n      // Now make sure they have the same keys.\n      for (let k = 0; k < keyCount; ++k) {\n        if (!hasOwnProperty.call(b, aKeys[k])) {\n          return false;\n        }\n      }\n\n      // Finally, check deep equality of all child properties.\n      for (let k = 0; k < keyCount; ++k) {\n        const key = aKeys[k];\n        if (!check(a[key], b[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n      // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n\n    case '[object Map]':\n    case '[object Set]': {\n      if (a.size !== b.size) return false;\n      if (previouslyCompared(a, b)) return true;\n\n      const aIterator = a.entries();\n      const isMap = aTag === '[object Map]';\n\n      while (true) {\n        const info = aIterator.next();\n        if (info.done) break;\n\n        // If a instanceof Set, aValue === aKey.\n        const [aKey, aValue] = info.value;\n\n        // So this works the same way for both Set and Map.\n        if (!b.has(aKey)) {\n          return false;\n        }\n\n        // However, we care about deep equality of values only when dealing\n        // with Map structures.\n        if (isMap && !check(aValue, b.get(aKey))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Uint16Array]':\n    case '[object Uint8Array]': // Buffer, in Node.js.\n    case '[object Uint32Array]':\n    case '[object Int32Array]':\n    case '[object Int8Array]':\n    case '[object Int16Array]':\n    case '[object ArrayBuffer]':\n      // DataView doesn't need these conversions, but the equality check is\n      // otherwise the same.\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n      // Fall through...\n    case '[object DataView]': {\n      let len = a.byteLength;\n      if (len === b.byteLength) {\n        while (len-- && a[len] === b[len]) {\n          // Keep looping as long as the bytes are equal.\n        }\n      }\n      return len === -1;\n    }\n\n    case '[object AsyncFunction]':\n    case '[object GeneratorFunction]':\n    case '[object AsyncGeneratorFunction]':\n    case '[object Function]': {\n      const aCode = fnToStr.call(a);\n      if (aCode !== fnToStr.call(b)) {\n        return false;\n      }\n\n      // We consider non-native functions equal if they have the same code\n      // (native functions require === because their code is censored).\n      // Note that this behavior is not entirely sound, since !== function\n      // objects with the same code can behave differently depending on\n      // their closure scope. However, any function can behave differently\n      // depending on the values of its input arguments (including this)\n      // and its calling context (including its closure scope), even\n      // though the function object is === to itself; and it is entirely\n      // possible for functions that are not === to behave exactly the\n      // same under all conceivable circumstances. Because none of these\n      // factors are statically decidable in JavaScript, JS function\n      // equality is not well-defined. This ambiguity allows us to\n      // consider the best possible heuristic among various imperfect\n      // options, and equating non-native functions that have the same\n      // code has enormous practical benefits, such as when comparing\n      // functions that are repeatedly passed as fresh function\n      // expressions within objects that are otherwise deeply equal. Since\n      // any function created from the same syntactic expression (in the\n      // same code location) will always stringify to the same code\n      // according to fnToStr.call, we can reasonably expect these\n      // repeatedly passed function expressions to have the same code, and\n      // thus behave \"the same\" (with all the caveats mentioned above),\n      // even though the runtime function objects are !== to one another.\n      return !endsWith(aCode, nativeCodeSuffix);\n    }\n  }\n\n  // Otherwise the values are not equal.\n  return false;\n}\n\nfunction definedKeys<TObject extends object>(obj: TObject) {\n  // Remember that the second argument to Array.prototype.filter will be\n  // used as `this` within the callback function.\n  return Object.keys(obj).filter(isDefinedKey, obj);\n}\nfunction isDefinedKey<TObject extends object>(\n  this: TObject,\n  key: keyof TObject,\n) {\n  return this[key] !== void 0;\n}\n\nconst nativeCodeSuffix = \"{ [native code] }\";\n\nfunction endsWith(full: string, suffix: string) {\n  const fromIndex = full.length - suffix.length;\n  return fromIndex >= 0 &&\n    full.indexOf(suffix, fromIndex) === fromIndex;\n}\n\nfunction previouslyCompared(a: object, b: object): boolean {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set);\n  }\n  bSet.add(b);\n  return false;\n}\n", "interface Node<K, V> {\n  key: K;\n  value: V;\n  newer: Node<K, V> | null;\n  older: Node<K, V> | null;\n}\n\nfunction defaultDispose() {}\n\nexport class Cache<K = any, V = any> {\n  private map = new Map<K, Node<K, V>>();\n  private newest: Node<K, V> | null = null;\n  private oldest: Node<K, V> | null = null;\n\n  constructor(\n    private max = Infinity,\n    public dispose: (value: V, key: K) => void = defaultDispose,\n  ) {}\n\n  public has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  public get(key: K): V | undefined {\n    const node = this.getNode(key);\n    return node && node.value;\n  }\n\n  private getNode(key: K): Node<K, V> | undefined {\n    const node = this.map.get(key);\n\n    if (node && node !== this.newest) {\n      const { older, newer } = node;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      node.older = this.newest;\n      node.older!.newer = node;\n\n      node.newer = null;\n      this.newest = node;\n\n      if (node === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return node;\n  }\n\n  public set(key: K, value: V): V {\n    let node = this.getNode(key);\n    if (node) {\n      return node.value = value;\n    }\n\n    node = {\n      key,\n      value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = node;\n    }\n\n    this.newest = node;\n    this.oldest = this.oldest || node;\n\n    this.map.set(key, node);\n\n    return node.value;\n  }\n\n  public clean() {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  }\n\n  public delete(key: K): boolean {\n    const node = this.map.get(key);\n    if (node) {\n      if (node === this.newest) {\n        this.newest = node.older;\n      }\n\n      if (node === this.oldest) {\n        this.oldest = node.newer;\n      }\n\n      if (node.newer) {\n        node.newer.older = node.older;\n      }\n\n      if (node.older) {\n        node.older.newer = node.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(node.value, key);\n\n      return true;\n    }\n\n    return false;\n  }\n}\n", "type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult, TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: TThis) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\nfunction maybe<T>(fn: () => T): T | undefined {\n  try {\n    return fn();\n  } catch (ignored) {}\n}\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\n\nconst host =\n  // Prefer globalThis when available.\n  // https://github.com/benjamn/wryware/issues/347\n  maybe(() => globalThis) ||\n  // Fall back to global, which works in Node.js and may be converted by some\n  // bundlers to the appropriate identifier (window, self, ...) depending on the\n  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n  maybe(() => global) ||\n  // Otherwise, use a dummy host that's local to this module. We used to fall\n  // back to using the Array constructor as a namespace, but that was flagged in\n  // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n  Object.create(null) as typeof Array;\n\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost: typeof host & {\n  [globalKey]?: typeof Slot;\n} = host;\n\nexport const Slot: ReturnType<typeof makeSlotClass> =\n  globalHost[globalKey] ||\n  // Earlier versions of this package stored the globalKey property on the Array\n  // constructor, so we check there as well, to prevent Slot class duplication.\n  (Array as typeof globalHost)[globalKey] ||\n  (function (Slot) {\n    try {\n      Object.defineProperty(globalHost, globalKey, {\n        value: Slot,\n        enumerable: false,\n        writable: false,\n        // When it was possible for globalHost to be the Array constructor (a\n        // legacy Slot dedup strategy), it was important for the property to be\n        // configurable:true so it could be deleted. That does not seem to be as\n        // important when globalHost is the global object, but I don't want to\n        // cause similar problems again, and configurable:true seems safest.\n        // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n        configurable: true\n      });\n    } finally {\n      return Slot;\n    }\n  })(makeSlotClass());\n", "import { Slot } from \"./slot.js\";\nexport { Slot }\nexport const { bind, noContext } = Slot;\n\n// Relying on the @types/node declaration of global.setTimeout can make\n// things tricky for dowstream projects (see PR #7).\ndeclare function setTimeout(\n  callback: (...args: any[]) => any,\n  ms?: number,\n  ...args: any[]\n): any;\n\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback: () => any, delay: number) {\n  return setTimeout(bind(callback), delay);\n}\n\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen<\n  TArgs extends any[],\n  TYield = any,\n  TReturn = any,\n  TNext = any,\n>(\n  genFn: (...args: TArgs) => Generator<TYield, TReturn, TNext>\n) {\n  return function (this: any) {\n    const gen = genFn.apply(this, arguments as any);\n\n    type Method = (\n      this: Generator<TYield, TReturn, TNext>,\n      arg: any,\n    ) => IteratorResult<TYield, TReturn>;\n\n    const boundNext: Method = bind(gen.next);\n    const boundThrow: Method = bind(gen.throw!);\n\n    return new Promise((resolve, reject) => {\n      function invoke(method: Method, argument: any) {\n        try {\n          var result: any = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = (value?: any) => invoke(boundNext, value);\n      const invokeThrow = (error: any) => invoke(boundThrow, error);\n      invokeNext();\n    });\n  } as (...args: TArgs) => Promise<any>;\n}\n\nfunction isPromiseLike(value: any): value is PromiseLike<any> {\n  return value && typeof value.then === \"function\";\n}\n\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers: Function[] = [];\nexport function wrapYieldingFiberMethods<F extends Function>(Fiber: F): F {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj: any, method: string) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments as any, this);\n      };\n    }\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\n", "import { Slot } from \"@wry/context\";\nimport { AnyEntry } from \"./entry.js\";\n\nexport const parentEntrySlot = new Slot<AnyEntry | undefined>();\n\nexport function nonReactive<R>(fn: () => R): R {\n  return parentEntrySlot.withValue(void 0, fn);\n}\n\nexport {\n  bind as bindContext,\n  noContext,\n  setTimeout,\n  asyncFromGen,\n} from \"@wry/context\";\n", "export const {\n  hasOwnProperty,\n} = Object.prototype;\n\nexport const arrayFromSet: <T>(set: Set<T>) => T[] =\n  Array.from ||\n  function (set) {\n    const array: any[] = [];\n    set.forEach(item => array.push(item));\n    return array;\n  };\n\nexport type Unsubscribable = {\n  unsubscribe?: void | (() => any);\n}\n\nexport function maybeUnsubscribe(entryOrDep: Unsubscribable) {\n  const { unsubscribe } = entryOrDep;\n  if (typeof unsubscribe === \"function\") {\n    entryOrDep.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n", "import { parentEntrySlot } from \"./context.js\";\nimport { OptimisticWrapOptions } from \"./index.js\";\nimport { Dep } from \"./dep.js\";\nimport { maybeUnsubscribe, arrayFromSet, Unsubscribable } from \"./helpers.js\";\n\nconst emptySetPool: Set<any>[] = [];\nconst POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition: any, optionalMessage?: string) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\n// Since exceptions are cached just like normal values, we need an efficient\n// way of representing unknown, ordinary, and exceptional values.\ntype Value<T> =\n  | []           // unknown\n  | [T]          // known value\n  | [void, any]; // known exception\n\nfunction valueIs(a: Value<any>, b: Value<any>) {\n  const len = a.length;\n  return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n    // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length &&\n    // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet<T>(value: Value<T>): T {\n  switch (value.length) {\n    case 0: throw new Error(\"unknown value\");\n    case 1: return value[0];\n    case 2: throw value[1];\n  }\n}\n\nfunction valueCopy<T>(value: Value<T>): Value<T> {\n  return value.slice(0) as Value<T>;\n}\n\nexport type AnyEntry = Entry<any, any>;\n\nexport class Entry<TArgs extends any[], TValue> {\n  public static count = 0;\n\n  public subscribe: OptimisticWrapOptions<TArgs>[\"subscribe\"];\n  public unsubscribe: Unsubscribable[\"unsubscribe\"];\n\n  public readonly parents = new Set<AnyEntry>();\n  public readonly childValues = new Map<AnyEntry, Value<any>>();\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  public dirtyChildren: Set<AnyEntry> | null = null;\n\n  public dirty = true;\n  public recomputing = false;\n  public readonly value: Value<TValue> = [];\n\n  constructor(\n    public readonly fn: (...args: TArgs) => TValue,\n  ) {\n    ++Entry.count;\n  }\n\n  public peek(): TValue | undefined {\n    if (this.value.length === 1 && !mightBeDirty(this)) {\n      rememberParent(this);\n      return this.value[0];\n    }\n  }\n\n  // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n  public recompute(args: TArgs): TValue {\n    assert(! this.recomputing, \"already recomputing\");\n    rememberParent(this);\n    return mightBeDirty(this)\n      ? reallyRecompute(this, args)\n      : valueGet(this.value);\n  }\n\n  public setDirty() {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this);\n    // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n    maybeUnsubscribe(this);\n  }\n\n  public dispose() {\n    this.setDirty();\n\n    // Sever any dependency relationships with our own children, so those\n    // children don't retain this parent Entry in their child.parents sets,\n    // thereby preventing it from being fully garbage collected.\n    forgetChildren(this);\n\n    // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n    eachParent(this, (parent, child) => {\n      parent.setDirty();\n      forgetChild(parent, this);\n    });\n  }\n\n  public forget() {\n    // The code that creates Entry objects in index.ts will replace this method\n    // with one that actually removes the Entry from the cache, which will also\n    // trigger the entry.dispose method.\n    this.dispose();\n  }\n\n  private deps: Set<Dep<any>> | null = null;\n\n  public dependOn(dep: Dep<any>) {\n    dep.add(this);\n    if (! this.deps) {\n      this.deps = emptySetPool.pop() || new Set<Set<AnyEntry>>();\n    }\n    this.deps.add(dep);\n  }\n\n  public forgetDeps() {\n    if (this.deps) {\n      arrayFromSet(this.deps).forEach(dep => dep.delete(this));\n      this.deps.clear();\n      emptySetPool.push(this.deps);\n      this.deps = null;\n    }\n  }\n}\n\nfunction rememberParent(child: AnyEntry) {\n  const parent = parentEntrySlot.getValue();\n  if (parent) {\n    child.parents.add(parent);\n\n    if (! parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry: AnyEntry, args: any[]) {\n  forgetChildren(entry);\n\n  // Set entry as the parent entry while calling recomputeNewValue(entry).\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);\n\n  if (maybeSubscribe(entry, args)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry: AnyEntry, args: any[]) {\n  entry.recomputing = true;\n  // Set entry.value as unknown.\n  entry.value.length = 0;\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  }\n  // Either way, this line is always reached.\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry: AnyEntry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry: AnyEntry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child: AnyEntry) {\n  eachParent(child, reportDirtyChild);\n}\n\nfunction reportClean(child: AnyEntry) {\n  eachParent(child, reportCleanChild);\n}\n\nfunction eachParent(\n  child: AnyEntry,\n  callback: (parent: AnyEntry, child: AnyEntry) => any,\n) {\n  const parentCount = child.parents.size;\n  if (parentCount) {\n    const parents = arrayFromSet(child.parents);\n    for (let i = 0; i < parentCount; ++i) {\n      callback(parents[i], child);\n    }\n  }\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n  const parentWasClean = !mightBeDirty(parent);\n\n  if (! parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child);\n\n  // If parent was clean before, it just became (possibly) dirty (according to\n  // mightBeDirty), since we just added child to parent.dirtyChildren.\n  if (parentWasClean) {\n    reportDirty(parent);\n  }\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(! mightBeDirty(child));\n\n  const childValue = parent.childValues.get(child)!;\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (! valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  const dc = parent.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      parent.dirtyChildren = null;\n    }\n  }\n}\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent: AnyEntry) {\n  if (parent.childValues.size > 0) {\n    parent.childValues.forEach((_value, child) => {\n      forgetChild(parent, child);\n    });\n  }\n\n  // Remove this parent Entry from any sets to which it was added by the\n  // addToSet method.\n  parent.forgetDeps();\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n  assert(parent.dirtyChildren === null);\n}\n\nfunction forgetChild(parent: AnyEntry, child: AnyEntry) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry: AnyEntry, args: any[]) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n", "import { AnyEntry } from \"./entry.js\";\nimport { OptimisticWrapOptions } from \"./index.js\";\nimport { parentEntrySlot } from \"./context.js\";\nimport {\n  hasOwnProperty,\n  Unsubscribable,\n  maybeUnsubscribe,\n  arrayFromSet,\n } from \"./helpers.js\";\n\ntype EntryMethodName = keyof typeof EntryMethods;\nconst EntryMethods = {\n  setDirty: true, // Mark parent Entry as needing to be recomputed (default)\n  dispose: true,  // Detach parent Entry from parents and children, but leave in LRU cache\n  forget: true,   // Fully remove parent Entry from LRU cache and computation graph\n};\n\nexport type OptimisticDependencyFunction<TKey> =\n  ((key: TKey) => void) & {\n    dirty: (key: TKey, entryMethodName?: EntryMethodName) => void;\n  };\n\nexport type Dep<TKey> = Set<AnyEntry> & {\n  subscribe: OptimisticWrapOptions<[TKey]>[\"subscribe\"];\n} & Unsubscribable;\n\nexport function dep<TKey>(options?: {\n  subscribe: Dep<TKey>[\"subscribe\"];\n}) {\n  const depsByKey = new Map<TKey, Dep<TKey>>();\n  const subscribe = options && options.subscribe;\n\n  function depend(key: TKey) {\n    const parent = parentEntrySlot.getValue();\n    if (parent) {\n      let dep = depsByKey.get(key);\n      if (!dep) {\n        depsByKey.set(key, dep = new Set as Dep<TKey>);\n      }\n      parent.dependOn(dep);\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(dep);\n        dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n\n  depend.dirty = function dirty(\n    key: TKey,\n    entryMethodName?: EntryMethodName,\n  ) {\n    const dep = depsByKey.get(key);\n    if (dep) {\n      const m: EntryMethodName = (\n        entryMethodName &&\n        hasOwnProperty.call(EntryMethods, entryMethodName)\n      ) ? entryMethodName : \"setDirty\";\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n      arrayFromSet(dep).forEach(entry => entry[m]());\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n\n  return depend as OptimisticDependencyFunction<TKey>;\n}\n", "import { Trie } from \"@wry/trie\";\n\nimport { Cache } from \"./cache.js\";\nimport { Entry, AnyEntry } from \"./entry.js\";\nimport { parentEntrySlot } from \"./context.js\";\n\n// These helper functions are important for making optimism work with\n// asynchronous code. In order to register parent-child dependencies,\n// optimism needs to know about any currently active parent computations.\n// In ordinary synchronous code, the parent context is implicit in the\n// execution stack, but asynchronous code requires some extra guidance in\n// order to propagate context from one async task segment to the next.\nexport {\n  bindContext,\n  noContext,\n  nonReactive,\n  setTimeout,\n  asyncFromGen,\n} from \"./context.js\";\n\n// A lighter-weight dependency, similar to OptimisticWrapperFunction, except\n// with only one argument, no makeCacheKey, no wrapped function to recompute,\n// and no result value. Useful for representing dependency leaves in the graph\n// of computation. Subscriptions are supported.\nexport { dep, OptimisticDependencyFunction } from \"./dep.js\";\n\n// The defaultMakeCacheKey function is remarkably powerful, because it gives\n// a unique object for any shallow-identical list of arguments. If you need\n// to implement a custom makeCacheKey function, you may find it helpful to\n// delegate the final work to defaultMakeCacheKey, which is why we export it\n// here. However, you may want to avoid defaultMakeCacheKey if your runtime\n// does not support WeakMap, or you have the ability to return a string key.\n// In those cases, just write your own custom makeCacheKey functions.\nlet defaultKeyTrie: Trie<object> | undefined;\nexport function defaultMakeCacheKey(...args: any[]): object {\n  const trie = defaultKeyTrie || (\n    defaultKeyTrie = new Trie(typeof WeakMap === \"function\")\n  );\n  return trie.lookupArray(args);\n}\n\n// If you're paranoid about memory leaks, or you want to avoid using WeakMap\n// under the hood, but you still need the behavior of defaultMakeCacheKey,\n// import this constructor to create your own tries.\nexport { Trie as KeyTrie }\n\nexport type OptimisticWrapperFunction<\n  TArgs extends any[],\n  TResult,\n  TKeyArgs extends any[] = TArgs,\n  TCacheKey = any,\n> = ((...args: TArgs) => TResult) & {\n  // Get the current number of Entry objects in the LRU cache.\n  readonly size: number;\n\n  // Snapshot of wrap options used to create this wrapper function.\n  options: OptimisticWrapOptions<TArgs, TKeyArgs, TCacheKey>;\n\n  // \"Dirty\" any cached Entry stored for the given arguments, marking that Entry\n  // and its ancestors as potentially needing to be recomputed. The .dirty(...)\n  // method of an optimistic function takes the same parameter types as the\n  // original function by default, unless a keyArgs function is configured, and\n  // then it matters that .dirty takes TKeyArgs instead of TArgs.\n  dirty: (...args: TKeyArgs) => void;\n  // A version of .dirty that accepts a key returned by .getKey.\n  dirtyKey: (key: TCacheKey) => void;\n\n  // Examine the current value without recomputing it.\n  peek: (...args: TKeyArgs) => TResult | undefined;\n  // A version of .peek that accepts a key returned by .getKey.\n  peekKey: (key: TCacheKey) => TResult | undefined;\n\n  // Completely remove the entry from the cache, dirtying any parent entries.\n  forget: (...args: TKeyArgs) => boolean;\n  // A version of .forget that accepts a key returned by .getKey.\n  forgetKey: (key: TCacheKey) => boolean;\n\n  // In order to use the -Key version of the above functions, you need a key\n  // rather than the arguments used to compute the key. These two functions take\n  // TArgs or TKeyArgs and return the corresponding TCacheKey. If no keyArgs\n  // function has been configured, TArgs will be the same as TKeyArgs, and thus\n  // getKey and makeCacheKey will be synonymous.\n  getKey: (...args: TArgs) => TCacheKey;\n\n  // This property is equivalent to the makeCacheKey function provided in the\n  // OptimisticWrapOptions, or (if no options.makeCacheKey function is provided)\n  // a default implementation of makeCacheKey.\n  makeCacheKey: (...args: TKeyArgs) => TCacheKey;\n};\n\nexport type OptimisticWrapOptions<\n  TArgs extends any[],\n  TKeyArgs extends any[] = TArgs,\n  TCacheKey = any,\n> = {\n  // The maximum number of cache entries that should be retained before the\n  // cache begins evicting the oldest ones.\n  max?: number;\n  // Transform the raw arguments to some other type of array, which will then\n  // be passed to makeCacheKey.\n  keyArgs?: (...args: TArgs) => TKeyArgs;\n  // The makeCacheKey function takes the same arguments that were passed to\n  // the wrapper function and returns a single value that can be used as a key\n  // in a Map to identify the cached result.\n  makeCacheKey?: (...args: TKeyArgs) => TCacheKey;\n  // If provided, the subscribe function should either return an unsubscribe\n  // function or return nothing.\n  subscribe?: (...args: TArgs) => void | (() => any);\n};\n\nconst caches = new Set<Cache<any, AnyEntry>>();\n\nexport function wrap<\n  TArgs extends any[],\n  TResult,\n  TKeyArgs extends any[] = TArgs,\n  TCacheKey = any,\n>(originalFunction: (...args: TArgs) => TResult, {\n  max = Math.pow(2, 16),\n  makeCacheKey = defaultMakeCacheKey,\n  keyArgs,\n  subscribe,\n}: OptimisticWrapOptions<TArgs, TKeyArgs> = Object.create(null)) {\n  const cache = new Cache<TCacheKey, Entry<TArgs, TResult>>(\n    max,\n    entry => entry.dispose(),\n  );\n\n  const optimistic = function (): TResult {\n    const key = makeCacheKey.apply(\n      null,\n      keyArgs ? keyArgs.apply(null, arguments as any) : arguments as any\n    );\n\n    if (key === void 0) {\n      return originalFunction.apply(null, arguments as any);\n    }\n\n    let entry = cache.get(key)!;\n    if (!entry) {\n      cache.set(key, entry = new Entry(originalFunction));\n      entry.subscribe = subscribe;\n      // Give the Entry the ability to trigger cache.delete(key), even though\n      // the Entry itself does not know about key or cache.\n      entry.forget = () => cache.delete(key);\n    }\n\n    const value = entry.recompute(\n      Array.prototype.slice.call(arguments) as TArgs,\n    );\n\n    // Move this entry to the front of the least-recently used queue,\n    // since we just finished computing its value.\n    cache.set(key, entry);\n\n    caches.add(cache);\n\n    // Clean up any excess entries in the cache, but only if there is no\n    // active parent entry, meaning we're not in the middle of a larger\n    // computation that might be flummoxed by the cleaning.\n    if (! parentEntrySlot.hasValue()) {\n      caches.forEach(cache => cache.clean());\n      caches.clear();\n    }\n\n    return value;\n  } as OptimisticWrapperFunction<TArgs, TResult, TKeyArgs, TCacheKey>;\n\n  Object.defineProperty(optimistic, \"size\", {\n    get() {\n      return cache[\"map\"].size;\n    },\n    configurable: false,\n    enumerable: false,\n  });\n\n  Object.freeze(optimistic.options = {\n    max,\n    makeCacheKey,\n    keyArgs,\n    subscribe,\n  });\n\n  function dirtyKey(key: TCacheKey) {\n    const entry = cache.get(key);\n    if (entry) {\n      entry.setDirty();\n    }\n  }\n  optimistic.dirtyKey = dirtyKey;\n  optimistic.dirty = function dirty() {\n    dirtyKey(makeCacheKey.apply(null, arguments as any));\n  };\n\n  function peekKey(key: TCacheKey) {\n    const entry = cache.get(key);\n    if (entry) {\n      return entry.peek();\n    }\n  }\n  optimistic.peekKey = peekKey;\n  optimistic.peek = function peek() {\n    return peekKey(makeCacheKey.apply(null, arguments as any));\n  };\n\n  function forgetKey(key: TCacheKey) {\n    return cache.delete(key);\n  }\n  optimistic.forgetKey = forgetKey;\n  optimistic.forget = function forget() {\n    return forgetKey(makeCacheKey.apply(null, arguments as any));\n  };\n\n  optimistic.makeCacheKey = makeCacheKey;\n  optimistic.getKey = keyArgs ? function getKey() {\n    return makeCacheKey.apply(null, keyArgs.apply(null, arguments as any));\n  } : makeCacheKey as (...args: any[]) => TCacheKey;\n\n  return Object.freeze(optimistic);\n}\n", "import type { DocumentNode } from \"graphql\";\nimport { wrap } from \"optimism\";\n\nimport type { StoreObject, Reference } from \"../../utilities/index.js\";\nimport { getFragmentQueryDocument } from \"../../utilities/index.js\";\nimport type { DataProxy } from \"./types/DataProxy.js\";\nimport type { Cache } from \"./types/Cache.js\";\n\nexport type Transaction<T> = (c: ApolloCache<T>) => void;\n\nexport abstract class ApolloCache<TSerialized> implements DataProxy {\n  public readonly assumeImmutableResults: boolean = false;\n\n  // required to implement\n  // core API\n  public abstract read<TData = any, TVariables = any>(\n    query: Cache.ReadOptions<TVariables, TData>\n  ): TData | null;\n  public abstract write<TData = any, TVariables = any>(\n    write: Cache.WriteOptions<TData, TVariables>\n  ): Reference | undefined;\n  public abstract diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T>;\n  public abstract watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void;\n\n  // Empty the cache and restart all current watches (unless\n  // options.discardWatches is true).\n  public abstract reset(options?: Cache.ResetOptions): Promise<void>;\n\n  // Remove whole objects from the cache by passing just options.id, or\n  // specific fields by passing options.field and/or options.args. If no\n  // options.args are provided, all fields matching options.field (even\n  // those with arguments) will be removed. Returns true iff any data was\n  // removed from the cache.\n  public abstract evict(options: Cache.EvictOptions): boolean;\n\n  // initializer / offline / ssr API\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public abstract restore(\n    serializedState: TSerialized\n  ): ApolloCache<TSerialized>;\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public abstract extract(optimistic?: boolean): TSerialized;\n\n  // Optimistic API\n\n  public abstract removeOptimistic(id: string): void;\n\n  // Transactional API\n\n  // The batch method is intended to replace/subsume both performTransaction\n  // and recordOptimisticTransaction, but performTransaction came first, so we\n  // provide a default batch implementation that's just another way of calling\n  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can\n  // override the batch method to do more interesting things with its options.\n  public batch<U>(options: Cache.BatchOptions<this, U>): U {\n    const optimisticId =\n      typeof options.optimistic === \"string\"\n        ? options.optimistic\n        : options.optimistic === false\n        ? null\n        : void 0;\n    let updateResult: U;\n    this.performTransaction(\n      () => (updateResult = options.update(this)),\n      optimisticId\n    );\n    return updateResult!;\n  }\n\n  public abstract performTransaction(\n    transaction: Transaction<TSerialized>,\n    // Although subclasses may implement recordOptimisticTransaction\n    // however they choose, the default implementation simply calls\n    // performTransaction with a string as the second argument, allowing\n    // performTransaction to handle both optimistic and non-optimistic\n    // (broadcast-batching) transactions. Passing null for optimisticId is\n    // also allowed, and indicates that performTransaction should apply\n    // the transaction non-optimistically (ignoring optimistic data).\n    optimisticId?: string | null\n  ): void;\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<TSerialized>,\n    optimisticId: string\n  ) {\n    this.performTransaction(transaction, optimisticId);\n  }\n\n  // Optional API\n\n  // Called once per input document, allowing the cache to make static changes\n  // to the query, such as adding __typename fields.\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  // Called before each ApolloLink request, allowing the cache to make dynamic\n  // changes to the query, such as filling in missing fragment definitions.\n  public transformForLink(document: DocumentNode): DocumentNode {\n    return document;\n  }\n\n  public identify(object: StoreObject | Reference): string | undefined {\n    return;\n  }\n\n  public gc(): string[] {\n    return [];\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    return false;\n  }\n\n  // DataProxy API\n  /**\n   *\n   * @param options\n   * @param optimistic\n   */\n  public readQuery<QueryType, TVariables = any>(\n    options: Cache.ReadQueryOptions<QueryType, TVariables>,\n    optimistic = !!options.optimistic\n  ): QueryType | null {\n    return this.read({\n      ...options,\n      rootId: options.id || \"ROOT_QUERY\",\n      optimistic,\n    });\n  }\n\n  // Make sure we compute the same (===) fragment query document every\n  // time we receive the same fragment in readFragment.\n  private getFragmentDoc = wrap(getFragmentQueryDocument);\n\n  public readFragment<FragmentType, TVariables = any>(\n    options: Cache.ReadFragmentOptions<FragmentType, TVariables>,\n    optimistic = !!options.optimistic\n  ): FragmentType | null {\n    return this.read({\n      ...options,\n      query: this.getFragmentDoc(options.fragment, options.fragmentName),\n      rootId: options.id,\n      optimistic,\n    });\n  }\n\n  public writeQuery<TData = any, TVariables = any>({\n    id,\n    data,\n    ...options\n  }: Cache.WriteQueryOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        dataId: id || \"ROOT_QUERY\",\n        result: data,\n      })\n    );\n  }\n\n  public writeFragment<TData = any, TVariables = any>({\n    id,\n    data,\n    fragment,\n    fragmentName,\n    ...options\n  }: Cache.WriteFragmentOptions<TData, TVariables>): Reference | undefined {\n    return this.write(\n      Object.assign(options, {\n        query: this.getFragmentDoc(fragment, fragmentName),\n        dataId: id,\n        result: data,\n      })\n    );\n  }\n\n  public updateQuery<TData = any, TVariables = any>(\n    options: Cache.UpdateQueryOptions<TData, TVariables>,\n    update: (data: TData | null) => TData | null | void\n  ): TData | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readQuery<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeQuery<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n\n  public updateFragment<TData = any, TVariables = any>(\n    options: Cache.UpdateFragmentOptions<TData, TVariables>,\n    update: (data: TData | null) => TData | null | void\n  ): TData | null {\n    return this.batch({\n      update(cache) {\n        const value = cache.readFragment<TData, TVariables>(options);\n        const data = update(value);\n        if (data === void 0 || data === null) return value;\n        cache.writeFragment<TData, TVariables>({ ...options, data });\n        return data;\n      },\n    });\n  }\n}\n", "import { DataProxy } from \"./DataProxy.js\";\nimport type { AllFieldsModifier, Modifiers } from \"./common.js\";\nimport type { ApolloCache } from \"../cache.js\";\n\nexport namespace Cache {\n  export type WatchCallback<TData = any> = (\n    diff: Cache.DiffResult<TData>,\n    lastDiff?: Cache.DiffResult<TData>\n  ) => void;\n\n  export interface ReadOptions<TVariables = any, TData = any>\n    extends DataProxy.Query<TVariables, TData> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n    returnPartialData?: boolean;\n    canonizeResults?: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends Omit<DataProxy.Query<TVariables, TResult>, \"id\">,\n      Omit<DataProxy.WriteOptions<TResult>, \"data\"> {\n    dataId?: string;\n    result: TResult;\n  }\n\n  export interface DiffOptions<TData = any, TVariables = any>\n    extends Omit<ReadOptions<TVariables, TData>, \"rootId\"> {\n    // The DiffOptions interface is currently just an alias for\n    // ReadOptions, though DiffOptions used to be responsible for\n    // declaring the returnPartialData option.\n  }\n\n  export interface WatchOptions<TData = any, TVariables = any>\n    extends DiffOptions<TData, TVariables> {\n    watcher?: object;\n    immediate?: boolean;\n    callback: WatchCallback<TData>;\n    lastDiff?: DiffResult<TData>;\n  }\n\n  export interface EvictOptions {\n    id?: string;\n    fieldName?: string;\n    args?: Record<string, any>;\n    broadcast?: boolean;\n  }\n\n  // Although you can call cache.reset() without options, its behavior can be\n  // configured by passing a Cache.ResetOptions object.\n  export interface ResetOptions {\n    discardWatches?: boolean;\n  }\n\n  export interface ModifyOptions<\n    Entity extends Record<string, any> = Record<string, any>,\n  > {\n    id?: string;\n    fields: Modifiers<Entity> | AllFieldsModifier<Entity>;\n    optimistic?: boolean;\n    broadcast?: boolean;\n  }\n\n  export interface BatchOptions<\n    TCache extends ApolloCache<any>,\n    TUpdateResult = void,\n  > {\n    // Same as the first parameter of performTransaction, except the cache\n    // argument will have the subclass type rather than ApolloCache.\n    update(cache: TCache): TUpdateResult;\n\n    // Passing a string for this option creates a new optimistic layer, with the\n    // given string as its layer.id, just like passing a string for the\n    // optimisticId parameter of performTransaction. Passing true is the same as\n    // passing undefined to performTransaction (running the batch operation\n    // against the current top layer of the cache), and passing false is the\n    // same as passing null (running the operation against root/non-optimistic\n    // cache data).\n    optimistic?: string | boolean;\n\n    // If you specify the ID of an optimistic layer using this option, that\n    // layer will be removed as part of the batch transaction, triggering at\n    // most one broadcast for both the transaction and the removal of the layer.\n    // Note: this option is needed because calling cache.removeOptimistic during\n    // the transaction function may not be not safe, since any modifications to\n    // cache layers may be discarded after the transaction finishes.\n    removeOptimistic?: string;\n\n    // If you want to find out which watched queries were invalidated during\n    // this batch operation, pass this optional callback function. Returning\n    // false from the callback will prevent broadcasting this result.\n    onWatchUpdated?: (\n      this: TCache,\n      watch: Cache.WatchOptions,\n      diff: Cache.DiffResult<any>,\n      lastDiff: Cache.DiffResult<any> | undefined\n    ) => any;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import ReadQueryOptions = DataProxy.ReadQueryOptions;\n  export import ReadFragmentOptions = DataProxy.ReadFragmentOptions;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import UpdateQueryOptions = DataProxy.UpdateQueryOptions;\n  export import UpdateFragmentOptions = DataProxy.UpdateFragmentOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n", "import type { DocumentNode, FieldNode } from \"graphql\";\n\nimport type {\n  Reference,\n  StoreObject,\n  StoreValue,\n  isReference,\n  AsStoreObject,\n} from \"../../../utilities/index.js\";\n\nimport type { StorageType } from \"../../inmemory/policies.js\";\n\n// The Readonly<T> type only really works for object types, since it marks\n// all of the object's properties as readonly, but there are many cases when\n// a generic type parameter like TExisting might be a string or some other\n// primitive type, in which case we need to avoid wrapping it with Readonly.\n// SafeReadonly<string> collapses to just string, which makes string\n// assignable to SafeReadonly<any>, whereas string is not assignable to\n// Readonly<any>, somewhat surprisingly.\nexport type SafeReadonly<T> = T extends object ? Readonly<T> : T;\n\nexport type MissingTree =\n  | string\n  | {\n      readonly [key: string]: MissingTree;\n    };\n\nexport class MissingFieldError extends Error {\n  constructor(\n    public readonly message: string,\n    public readonly path: MissingTree | Array<string | number>,\n    public readonly query: DocumentNode,\n    public readonly variables?: Record<string, any>\n  ) {\n    // 'Error' breaks prototype chain here\n    super(message);\n\n    if (Array.isArray(this.path)) {\n      this.missing = this.message;\n      for (let i = this.path.length - 1; i >= 0; --i) {\n        this.missing = { [this.path[i]]: this.missing };\n      }\n    } else {\n      this.missing = this.path;\n    }\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully supported\n    // on Android (see issue #3236).\n    (this as any).__proto__ = MissingFieldError.prototype;\n  }\n\n  public readonly missing: MissingTree;\n}\n\nexport interface FieldSpecifier {\n  typename?: string;\n  fieldName: string;\n  field?: FieldNode;\n  args?: Record<string, any>;\n  variables?: Record<string, any>;\n}\n\nexport interface ReadFieldOptions extends FieldSpecifier {\n  from?: StoreObject | Reference;\n}\n\nexport interface ReadFieldFunction {\n  <V = StoreValue>(options: ReadFieldOptions): SafeReadonly<V> | undefined;\n  <V = StoreValue>(\n    fieldName: string,\n    from?: StoreObject | Reference\n  ): SafeReadonly<V> | undefined;\n}\n\nexport type ToReferenceFunction = (\n  objOrIdOrRef: StoreObject | string | Reference,\n  mergeIntoStore?: boolean\n) => Reference | undefined;\n\nexport type CanReadFunction = (value: StoreValue) => boolean;\n\ndeclare const _deleteModifier: unique symbol;\nexport interface DeleteModifier {\n  [_deleteModifier]: true;\n}\ndeclare const _invalidateModifier: unique symbol;\nexport interface InvalidateModifier {\n  [_invalidateModifier]: true;\n}\n\nexport type ModifierDetails = {\n  DELETE: DeleteModifier;\n  INVALIDATE: InvalidateModifier;\n  fieldName: string;\n  storeFieldName: string;\n  readField: ReadFieldFunction;\n  canRead: CanReadFunction;\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n  storage: StorageType;\n};\n\nexport type Modifier<T> = (\n  value: T,\n  details: ModifierDetails\n) => T | DeleteModifier | InvalidateModifier;\n\ntype StoreObjectValueMaybeReference<StoreVal> = StoreVal extends Array<\n  infer Item extends Record<string, any>\n>\n  ? ReadonlyArray<AsStoreObject<Item> | Reference>\n  : StoreVal extends Record<string, any>\n  ? AsStoreObject<StoreVal> | Reference\n  : StoreVal;\n\nexport type AllFieldsModifier<Entity extends Record<string, any>> = Modifier<\n  Entity[keyof Entity] extends infer Value\n    ? StoreObjectValueMaybeReference<Exclude<Value, undefined>>\n    : never\n>;\n\nexport type Modifiers<T extends Record<string, any> = Record<string, unknown>> =\n  Partial<{\n    [FieldName in keyof T]: Modifier<\n      StoreObjectValueMaybeReference<Exclude<T[FieldName], undefined>>\n    >;\n  }>;\n", "import type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { NormalizedCache, InMemoryCacheConfig } from \"./types.js\";\n\nimport type { KeyFieldsContext } from \"./policies.js\";\nimport type { FragmentRegistryAPI } from \"./fragmentRegistry.js\";\n\nimport type {\n  Reference,\n  StoreValue,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from \"../../utilities/index.js\";\n\nexport const { hasOwnProperty: hasOwn } = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id)\n        ? { id }\n        : !isNullish(_id)\n        ? { _id }\n        : void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${\n        typeof id === \"number\" || typeof id === \"string\"\n          ? id\n          : JSON.stringify(id)\n      }`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference\n): string | undefined {\n  return isReference(objectOrReference)\n    ? (store.get(objectOrReference.__ref, \"__typename\") as string)\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result)\n      ? result.every((item) =>\n          selectionSetMatchesResult(selectionSet, item, variables)\n        )\n      : selectionSet.selections.every((field) => {\n          if (isField(field) && shouldInclude(field, variables)) {\n            const key = resultKeyNameFromField(field);\n            return (\n              hasOwn.call(result, key) &&\n              (!field.selectionSet ||\n                selectionSetMatchesResult(\n                  field.selectionSet,\n                  result[key],\n                  variables\n                ))\n            );\n          }\n          // If the selection has been skipped with @skip(true) or\n          // @include(false), it should not count against the matching. If\n          // the selection is not a field, it must be a fragment (inline or\n          // named). We will determine if selectionSetMatchesResult for that\n          // fragment when we get to it, so for now we return true.\n          return true;\n        });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue\n): value is StoreObject {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\n\nimport type {\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  isReference,\n  makeReference,\n  DeepMerger,\n  maybeDeepFreeze,\n  canUseWeakMap,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\nimport type { NormalizedCache, NormalizedCacheObject } from \"./types.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nimport type { Policies, StorageType } from \"./policies.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  SafeReadonly,\n  Modifier,\n  Modifiers,\n  ReadFieldOptions,\n  ToReferenceFunction,\n  CanReadFunction,\n  InvalidateModifier,\n  DeleteModifier,\n  ModifierDetails,\n} from \"../core/types/common.js\";\n\nconst DELETE: DeleteModifier = Object.create(null);\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE: InvalidateModifier = Object.create(null);\n\nexport abstract class EntityStore implements NormalizedCache {\n  protected data: NormalizedCacheObject = Object.create(null);\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (\n      fieldName === \"__typename\" &&\n      hasOwn.call(this.policies.rootTypenamesById, dataId)\n    ) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(\n    dataId: string,\n    dependOnExistence?: boolean\n  ): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  }\n\n  public merge(older: string | StoreObject, newer: StoreObject | string): void {\n    let dataId: string | undefined;\n\n    // Convert unexpected references to ID strings.\n    if (isReference(older)) older = older.__ref;\n    if (isReference(newer)) newer = newer.__ref;\n\n    const existing: StoreObject | undefined =\n      typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n\n    const incoming: StoreObject | undefined =\n      typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n\n    // If newer was a string ID, but that ID was not defined in this store,\n    // then there are no fields to be merged, so we're done.\n    if (!incoming) return;\n\n    invariant(typeof dataId === \"string\", \"store.merge expects a string ID\");\n\n    const merged: StoreObject = new DeepMerger(storeObjectReconciler).merge(\n      existing,\n      incoming\n    );\n\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = Object.create(null);\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach((storeFieldName) => {\n          if (\n            !existing ||\n            existing[storeFieldName] !== merged[storeFieldName]\n          ) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (\n              fieldName !== storeFieldName &&\n              !this.policies.hasKeyArgs(merged.__typename, fieldName)\n            ) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        if (\n          fieldsToDirty.__typename &&\n          !(existing && existing.__typename) &&\n          // Since we return default root __typename strings\n          // automatically from store.get, we don't need to dirty the\n          // ROOT_QUERY.__typename field if merged.__typename is equal\n          // to the default string (usually \"Query\").\n          this.policies.rootTypenamesById[dataId] === merged.__typename\n        ) {\n          delete fieldsToDirty.__typename;\n        }\n\n        Object.keys(fieldsToDirty).forEach((fieldName) =>\n          this.group.dirty(dataId as string, fieldName)\n        );\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers<Record<string, any>>\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = Object.create(null);\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference\n        ) =>\n          this.policies.readField<V>(\n            typeof fieldNameOrOptions === \"string\"\n              ? {\n                  fieldName: fieldNameOrOptions,\n                  from: from || makeReference(dataId),\n                }\n              : fieldNameOrOptions,\n            { store: this }\n          ),\n      } satisfies Partial<ModifierDetails>;\n\n      Object.keys(storeObject).forEach((storeFieldName) => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> | undefined =\n          typeof fields === \"function\"\n            ? fields\n            : fields[storeFieldName] || fields[fieldName];\n        if (modify) {\n          let newValue =\n            modify === delModifier\n              ? DELETE\n              : modify(maybeDeepFreeze(fieldValue), {\n                  ...sharedDetails,\n                  fieldName,\n                  storeFieldName,\n                  storage: this.getStorage(dataId, storeFieldName),\n                });\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue;\n\n              if (__DEV__) {\n                const checkReference = (ref: Reference) => {\n                  if (this.lookup(ref.__ref) === undefined) {\n                    invariant.warn(\n                      \"cache.modify: You are trying to write a Reference that is not part of the store: %o\\n\" +\n                        \"Please make sure to set the `mergeIntoStore` parameter to `true` when creating a Reference that is not part of the store yet:\\n\" +\n                        \"`toReference(object, true)`\",\n                      ref\n                    );\n                    return true;\n                  }\n                };\n                if (isReference(newValue)) {\n                  checkReference(newValue);\n                } else if (Array.isArray(newValue)) {\n                  // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                  let seenReference: boolean = false;\n                  let someNonReference: unknown;\n                  for (const value of newValue) {\n                    if (isReference(value)) {\n                      seenReference = true;\n                      if (checkReference(value)) break;\n                    } else {\n                      // Do not warn on primitive values, since those could never be represented\n                      // by a reference. This is a valid (albeit uncommon) use case.\n                      if (typeof value === \"object\" && !!value) {\n                        const [id] = this.policies.identify(value);\n                        // check if object could even be referenced, otherwise we are not interested in it for this warning\n                        if (id) {\n                          someNonReference = value;\n                        }\n                      }\n                    }\n                    if (seenReference && someNonReference !== undefined) {\n                      invariant.warn(\n                        \"cache.modify: Writing an array with a mix of both References and Objects will not result in the Objects being normalized correctly.\\n\" +\n                          \"Please convert the object instance %o to a Reference before writing it to the cache by calling `toReference(object, true)`.\",\n                        someNonReference\n                      );\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName =\n        fieldName && args\n          ? this.policies.getStoreFieldName({ typename, fieldName, args })\n          : fieldName;\n      return this.modify(\n        dataId,\n        storeFieldName\n          ? {\n              [storeFieldName]: delModifier,\n            }\n          : delModifier\n      );\n    }\n    return false;\n  }\n\n  public evict(options: Cache.EvictOptions, limit: EntityStore): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer && this !== limit) {\n        evicted = this.parent.evict(options, limit) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach((id) => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach((dataId) => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach((dataId) => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = Object.create(null);\n\n  public retain(rootId: string): number {\n    return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach((id) => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach((id) => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = Object.create(null);\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = (this.refs[dataId] = Object.create(null));\n      const root = this.data[dataId];\n      if (!root) return found;\n\n      const workSet = new Set<Record<string | number, any>>([root]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      workSet.forEach((obj) => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n          // In rare cases, a { __ref } Reference object may have other fields.\n          // This often indicates a mismerging of References with StoreObjects,\n          // but garbage collection should not be fooled by a stray __ref\n          // property in a StoreObject (ignoring all the other fields just\n          // because the StoreObject looks like a Reference). To avoid this\n          // premature termination of findChildRefIds recursion, we fall through\n          // to the code below, which will handle any other properties of obj.\n        }\n        if (isNonNullObject(obj)) {\n          Object.keys(obj).forEach((key) => {\n            const child = obj[key];\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            if (isNonNullObject(child)) {\n              workSet.add(child);\n            }\n          });\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  public makeCacheKey(...args: any[]): object;\n  public makeCacheKey() {\n    return this.group.keyMaker.lookupArray(arguments);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string\n  ) =>\n    maybeDeepFreeze(\n      isReference(objectOrReference)\n        ? this.get(objectOrReference.__ref, storeFieldName)\n        : objectOrReference && objectOrReference[storeFieldName]\n    ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = (objOrRef) => {\n    return isReference(objOrRef)\n      ? this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (objOrIdOrRef, mergeIntoStore) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public keyMaker: Trie<object>;\n\n  constructor(\n    public readonly caching: boolean,\n    private parent: CacheGroup | null = null\n  ) {\n    this.resetCaching();\n  }\n\n  public resetCaching() {\n    this.d = this.caching ? dep<string>() : null;\n    this.keyMaker = new Trie(canUseWeakMap);\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n      if (this.parent) {\n        this.parent.depend(dataId, storeFieldName);\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(\n        makeDepKey(dataId, storeFieldName),\n        // When storeFieldName === \"__exists\", that means the entity identified\n        // by dataId has either disappeared from the cache or was newly added,\n        // so the result caching system would do well to \"forget everything it\n        // knows\" about that object. To achieve that kind of invalidation, we\n        // not only dirty the associated result cache entry, but also remove it\n        // completely from the dependency graph. For the optimism implementation\n        // details, see https://github.com/benjamn/optimism/pull/195.\n        storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\"\n      );\n    }\n  }\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + \"#\" + dataId;\n}\n\nexport function maybeDependOnExistenceOfEntity(\n  store: NormalizedCache,\n  entityId: string\n) {\n  if (supportsResultCaching(store)) {\n    // We use this pseudo-field __exists elsewhere in the EntityStore code to\n    // represent changes in the existence of the entity object identified by\n    // entityId. This dependency gets reliably dirtied whenever an object with\n    // this ID is deleted (or newly created) within this group, so any result\n    // cache entries (for example, StoreReader#executeSelectionSet results) that\n    // depend on __exists for this entityId will get dirtied as well, leading to\n    // the eventual recomputation (instead of reuse) of those result objects the\n    // next time someone reads them from the cache.\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n\nexport namespace EntityStore {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  export class Root extends EntityStore {\n    constructor({\n      policies,\n      resultCaching = true,\n      seed,\n    }: {\n      policies: Policies;\n      resultCaching?: boolean;\n      seed?: NormalizedCacheObject;\n    }) {\n      super(policies, new CacheGroup(resultCaching));\n      if (seed) this.replace(seed);\n    }\n\n    public readonly stump = new Stump(this);\n\n    public addLayer(\n      layerId: string,\n      replay: (layer: EntityStore) => any\n    ): Layer {\n      // Adding an optimistic Layer on top of the Root actually adds the Layer\n      // on top of the Stump, so the Stump always comes between the Root and\n      // any Layer objects that we've added.\n      return this.stump.addLayer(layerId, replay);\n    }\n\n    public removeLayer(): Root {\n      // Never remove the root layer.\n      return this;\n    }\n\n    public readonly storageTrie = new Trie<StorageType>(canUseWeakMap);\n    public getStorage(): StorageType {\n      return this.storageTrie.lookupArray(arguments);\n    }\n  }\n}\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(layerId: string, replay: (layer: EntityStore) => any): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        // Dirty every ID we're removing. Technically we might be able to avoid\n        // dirtying fields that have values in higher layers, but we don't have\n        // easy access to higher layers here, and we're about to recreate those\n        // layers anyway (see parent.addLayer below).\n        Object.keys(this.data).forEach((dataId) => {\n          const ownStoreObject = this.data[dataId];\n          const parentStoreObject = parent[\"lookup\"](dataId);\n          if (!parentStoreObject) {\n            // The StoreObject identified by dataId was defined in this layer\n            // but will be undefined in the parent layer, so we can delete the\n            // whole entity using this.delete(dataId). Since we're about to\n            // throw this layer away, the only goal of this deletion is to dirty\n            // the removed fields.\n            this.delete(dataId);\n          } else if (!ownStoreObject) {\n            // This layer had an entry for dataId but it was undefined, which\n            // means the entity was deleted in this layer, and it's about to\n            // become undeleted when we remove this layer, so we need to dirty\n            // all fields that are about to be reexposed.\n            this.group.dirty(dataId, \"__exists\");\n            Object.keys(parentStoreObject).forEach((storeFieldName) => {\n              this.group.dirty(dataId, storeFieldName);\n            });\n          } else if (ownStoreObject !== parentStoreObject) {\n            // If ownStoreObject is not exactly the same as parentStoreObject,\n            // dirty any fields whose values will change as a result of this\n            // removal.\n            Object.keys(ownStoreObject).forEach((storeFieldName) => {\n              if (\n                !equal(\n                  ownStoreObject[storeFieldName],\n                  parentStoreObject[storeFieldName]\n                )\n              ) {\n                this.group.dirty(dataId, storeFieldName);\n              }\n            });\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId)\n      ? {\n          ...fromParent,\n          ...super.findChildRefIds(dataId),\n        }\n      : fromParent;\n  }\n\n  public getStorage(): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage.apply(p, arguments);\n  }\n}\n\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nclass Stump extends Layer {\n  constructor(root: EntityStore.Root) {\n    super(\n      \"EntityStore.Stump\",\n      root,\n      () => {},\n      new CacheGroup(root.group.caching, root.group)\n    );\n  }\n\n  public removeLayer() {\n    // Never remove the Stump layer.\n    return this;\n  }\n\n  public merge() {\n    // We never want to write any data into the Stump, so we forward any merge\n    // calls to the Root instead. Another option here would be to throw an\n    // exception, but the toReference(object, true) function can sometimes\n    // trigger Stump writes (which used to be Root writes, before the Stump\n    // concept was introduced).\n    return this.parent.merge.apply(this.parent, arguments);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n", "import { Trie } from \"@wry/trie\";\nimport {\n  canUseWeakMap,\n  canUseWeakSet,\n  isNonNullObject as isObjectOrArray,\n} from \"../../utilities/index.js\";\nimport { isArray } from \"./helpers.js\";\n\nfunction shallowCopy<T>(value: T): T {\n  if (isObjectOrArray(value)) {\n    return isArray(value)\n      ? (value.slice(0) as any as T)\n      : { __proto__: Object.getPrototypeOf(value), ...value };\n  }\n  return value;\n}\n\n// When programmers talk about the \"canonical form\" of an object, they\n// usually have the following meaning in mind, which I've copied from\n// https://en.wiktionary.org/wiki/canonical_form:\n//\n// 1. A standard or normal presentation of a mathematical entity [or\n//    object]. A canonical form is an element of a set of representatives\n//    of equivalence classes of forms such that there is a function or\n//    procedure which projects every element of each equivalence class\n//    onto that one element, the canonical form of that equivalence\n//    class. The canonical form is expected to be simpler than the rest of\n//    the forms in some way.\n//\n// That's a long-winded way of saying any two objects that have the same\n// canonical form may be considered equivalent, even if they are !==,\n// which usually means the objects are structurally equivalent (deeply\n// equal), but don't necessarily use the same memory.\n//\n// Like a literary or musical canon, this ObjectCanon class represents a\n// collection of unique canonical items (JavaScript objects), with the\n// important property that canon.admit(a) === canon.admit(b) if a and b\n// are deeply equal to each other. In terms of the definition above, the\n// canon.admit method is the \"function or procedure which projects every\"\n// object \"onto that one element, the canonical form.\"\n//\n// In the worst case, the canonicalization process may involve looking at\n// every property in the provided object tree, so it takes the same order\n// of time as deep equality checking. Fortunately, already-canonicalized\n// objects are returned immediately from canon.admit, so the presence of\n// canonical subtrees tends to speed up canonicalization.\n//\n// Since consumers of canonical objects can check for deep equality in\n// constant time, canonicalizing cache results can massively improve the\n// performance of application code that skips re-rendering unchanged\n// results, such as \"pure\" UI components in a framework like React.\n//\n// Of course, since canonical objects may be shared widely between\n// unrelated consumers, it's important to think of them as immutable, even\n// though they are not actually frozen with Object.freeze in production,\n// due to the extra performance overhead that comes with frozen objects.\n//\n// Custom scalar objects whose internal class name is neither Array nor\n// Object can be included safely in the admitted tree, but they will not\n// be replaced with a canonical version (to put it another way, they are\n// assumed to be canonical already).\n//\n// If we ignore custom objects, no detection of cycles or repeated object\n// references is currently required by the StoreReader class, since\n// GraphQL result objects are JSON-serializable trees (and thus contain\n// neither cycles nor repeated subtrees), so we can avoid the complexity\n// of keeping track of objects we've already seen during the recursion of\n// the admit method.\n//\n// In the future, we may consider adding additional cases to the switch\n// statement to handle other common object types, such as \"[object Date]\"\n// objects, as needed.\nexport class ObjectCanon {\n  // Set of all canonical objects this ObjectCanon has admitted, allowing\n  // canon.admit to return previously-canonicalized objects immediately.\n  private known = new (canUseWeakSet ? WeakSet : Set)<object>();\n\n  // Efficient storage/lookup structure for canonical objects.\n  private pool = new Trie<{\n    array?: any[];\n    object?: Record<string, any>;\n    keys?: SortedKeysInfo;\n  }>(canUseWeakMap);\n\n  public isKnown(value: any): boolean {\n    return isObjectOrArray(value) && this.known.has(value);\n  }\n\n  // Make the ObjectCanon assume this value has already been\n  // canonicalized.\n  private passes = new WeakMap<object, object>();\n  public pass<T>(value: T): T;\n  public pass(value: any) {\n    if (isObjectOrArray(value)) {\n      const copy = shallowCopy(value);\n      this.passes.set(copy, value);\n      return copy;\n    }\n    return value;\n  }\n\n  // Returns the canonical version of value.\n  public admit<T>(value: T): T;\n  public admit(value: any) {\n    if (isObjectOrArray(value)) {\n      const original = this.passes.get(value);\n      if (original) return original;\n\n      const proto = Object.getPrototypeOf(value);\n      switch (proto) {\n        case Array.prototype: {\n          if (this.known.has(value)) return value;\n          const array: any[] = (value as any[]).map(this.admit, this);\n          // Arrays are looked up in the Trie using their recursively\n          // canonicalized elements, and the known version of the array is\n          // preserved as node.array.\n          const node = this.pool.lookupArray(array);\n          if (!node.array) {\n            this.known.add((node.array = array));\n            // Since canonical arrays may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(array);\n            }\n          }\n          return node.array;\n        }\n\n        case null:\n        case Object.prototype: {\n          if (this.known.has(value)) return value;\n          const proto = Object.getPrototypeOf(value);\n          const array = [proto];\n          const keys = this.sortedKeys(value);\n          array.push(keys.json);\n          const firstValueIndex = array.length;\n          keys.sorted.forEach((key) => {\n            array.push(this.admit((value as any)[key]));\n          });\n          // Objects are looked up in the Trie by their prototype (which\n          // is *not* recursively canonicalized), followed by a JSON\n          // representation of their (sorted) keys, followed by the\n          // sequence of recursively canonicalized values corresponding to\n          // those keys. To keep the final results unambiguous with other\n          // sequences (such as arrays that just happen to contain [proto,\n          // keys.json, value1, value2, ...]), the known version of the\n          // object is stored as node.object.\n          const node = this.pool.lookupArray(array);\n          if (!node.object) {\n            const obj = (node.object = Object.create(proto));\n            this.known.add(obj);\n            keys.sorted.forEach((key, i) => {\n              obj[key] = array[firstValueIndex + i];\n            });\n            // Since canonical objects may be shared widely between\n            // unrelated consumers, it's important to regard them as\n            // immutable, even if they are not frozen in production.\n            if (__DEV__) {\n              Object.freeze(obj);\n            }\n          }\n          return node.object;\n        }\n      }\n    }\n    return value;\n  }\n\n  // It's worthwhile to cache the sorting of arrays of strings, since the\n  // same initial unsorted arrays tend to be encountered many times.\n  // Fortunately, we can reuse the Trie machinery to look up the sorted\n  // arrays in linear time (which is faster than sorting large arrays).\n  private sortedKeys(obj: object) {\n    const keys = Object.keys(obj);\n    const node = this.pool.lookupArray(keys);\n    if (!node.keys) {\n      keys.sort();\n      const json = JSON.stringify(keys);\n      if (!(node.keys = this.keysByJSON.get(json))) {\n        this.keysByJSON.set(json, (node.keys = { sorted: keys, json }));\n      }\n    }\n    return node.keys;\n  }\n  // Arrays that contain the same elements in a different order can share\n  // the same SortedKeysInfo object, to save memory.\n  private keysByJSON = new Map<string, SortedKeysInfo>();\n\n  // This has to come last because it depends on keysByJSON.\n  public readonly empty = this.admit({});\n}\n\ntype SortedKeysInfo = {\n  sorted: string[];\n  json: string;\n};\n\n// Since the keys of canonical objects are always created in lexicographically\n// sorted order, we can use the ObjectCanon to implement a fast and stable\n// version of JSON.stringify, which automatically sorts object keys.\nexport const canonicalStringify = Object.assign(\n  function (value: any): string {\n    if (isObjectOrArray(value)) {\n      if (stringifyCanon === void 0) {\n        resetCanonicalStringify();\n      }\n      const canonical = stringifyCanon.admit(value);\n      let json = stringifyCache.get(canonical);\n      if (json === void 0) {\n        stringifyCache.set(canonical, (json = JSON.stringify(canonical)));\n      }\n      return json;\n    }\n    return JSON.stringify(value);\n  },\n  {\n    reset: resetCanonicalStringify,\n  }\n);\n\n// Can be reset by calling canonicalStringify.reset().\nlet stringifyCanon: ObjectCanon;\nlet stringifyCache: WeakMap<object, string>;\n\nfunction resetCanonicalStringify() {\n  stringifyCanon = new ObjectCanon();\n  stringifyCache = new (canUseWeakMap ? WeakMap : Map)();\n}\n", "import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type { DocumentNode, FieldNode, SelectionSetNode } from \"graphql\";\nimport { Kind } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\n\nimport type {\n  Reference,\n  StoreObject,\n  FragmentMap,\n  FragmentMapFunction,\n} from \"../../utilities/index.js\";\nimport {\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  makeReference,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getMainDefinition,\n  getQueryDefinition,\n  getFragmentFromSelection,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  DeepMerger,\n  isNonNullObject,\n  canUseWeakMap,\n  compact,\n} from \"../../utilities/index.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport type {\n  DiffQueryAgainstStoreOptions,\n  InMemoryCacheConfig,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  maybeDependOnExistenceOfEntity,\n  supportsResultCaching,\n} from \"./entityStore.js\";\nimport {\n  isArray,\n  extractFragmentContext,\n  getTypenameFromStoreObject,\n  shouldCanonizeResults,\n} from \"./helpers.js\";\nimport type { Policies } from \"./policies.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { MissingTree } from \"../core/types/common.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { canonicalStringify, ObjectCanon } from \"./object-canon.js\";\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  canonizeResults: boolean;\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n}\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingTree;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: readonly any[];\n  enclosingRef: Reference;\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache;\n  addTypename?: boolean;\n  resultCacheMaxSize?: number;\n  canonizeResults?: boolean;\n  canon?: ObjectCanon;\n  fragments?: InMemoryCacheConfig[\"fragments\"];\n}\n\n// Arguments type after keyArgs translation.\ntype ExecSelectionSetKeyArgs = [\n  SelectionSetNode,\n  StoreObject | Reference,\n  ReadMergeModifyContext,\n  boolean,\n];\n\nfunction execSelectionSetKeyArgs(\n  options: ExecSelectionSetOptions\n): ExecSelectionSetKeyArgs {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults,\n  ];\n}\n\nexport class StoreReader {\n  // cached version of executeSelectionSet\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    ExecSelectionSetKeyArgs\n  >;\n\n  // cached version of executeSubSelectedArray\n  private executeSubSelectedArray: OptimisticWrapperFunction<\n    [ExecSubSelectedArrayOptions],\n    ExecResult<any>,\n    [ExecSubSelectedArrayOptions]\n  >;\n\n  private config: {\n    cache: InMemoryCache;\n    addTypename: boolean;\n    resultCacheMaxSize?: number;\n    canonizeResults: boolean;\n    fragments?: InMemoryCacheConfig[\"fragments\"];\n  };\n\n  private knownResults = new (canUseWeakMap ? WeakMap : Map)<\n    Record<string, any>,\n    SelectionSetNode\n  >();\n\n  public canon: ObjectCanon;\n  public resetCanon() {\n    this.canon = new ObjectCanon();\n  }\n\n  constructor(config: StoreReaderConfig) {\n    this.config = compact(config, {\n      addTypename: config.addTypename !== false,\n      canonizeResults: shouldCanonizeResults(config),\n    });\n\n    this.canon = config.canon || new ObjectCanon();\n\n    this.executeSelectionSet = wrap(\n      (options) => {\n        const { canonizeResults } = options.context;\n\n        const peekArgs = execSelectionSetKeyArgs(options);\n\n        // Negate this boolean option so we can find out if we've already read\n        // this result using the other boolean value.\n        peekArgs[3] = !canonizeResults;\n\n        const other = this.executeSelectionSet.peek(...peekArgs);\n\n        if (other) {\n          if (canonizeResults) {\n            return {\n              ...other,\n              // If we previously read this result without canonizing it, we can\n              // reuse that result simply by canonizing it now.\n              result: this.canon.admit(other.result),\n            };\n          }\n          // If we previously read this result with canonization enabled, we can\n          // return that canonized result as-is.\n          return other;\n        }\n\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n\n        // Finally, if we didn't find any useful previous results, run the real\n        // execSelectionSetImpl method with the given options.\n        return this.execSelectionSetImpl(options);\n      },\n      {\n        max: this.config.resultCacheMaxSize,\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey(selectionSet, parent, context, canonizeResults) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(\n              selectionSet,\n              isReference(parent) ? parent.__ref : parent,\n              context.varString,\n              canonizeResults\n            );\n          }\n        },\n      }\n    );\n\n    this.executeSubSelectedArray = wrap(\n      (options: ExecSubSelectedArrayOptions) => {\n        maybeDependOnExistenceOfEntity(\n          options.context.store,\n          options.enclosingRef.__ref\n        );\n        return this.execSubSelectedArrayImpl(options);\n      },\n      {\n        max: this.config.resultCacheMaxSize,\n        makeCacheKey({ field, array, context }) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        },\n      }\n    );\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = \"ROOT_QUERY\",\n    variables,\n    returnPartialData = true,\n    canonizeResults = this.config.canonizeResults,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables!,\n    };\n\n    const rootRef = makeReference(rootId);\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: rootRef,\n      enclosingRef: rootRef,\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: canonicalStringify(variables),\n        canonizeResults,\n        ...extractFragmentContext(query, this.config.fragments),\n      },\n    });\n\n    let missing: MissingFieldError[] | undefined;\n    if (execResult.missing) {\n      // For backwards compatibility we still report an array of\n      // MissingFieldError objects, even though there will only ever be at most\n      // one of them, now that all missing field error messages are grouped\n      // together in the execResult.missing tree.\n      missing = [\n        new MissingFieldError(\n          firstMissing(execResult.missing)!,\n          execResult.missing,\n          query,\n          variables\n        ),\n      ];\n      if (!returnPartialData) {\n        throw missing[0];\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !missing,\n      missing,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext\n  ): boolean {\n    if (\n      supportsResultCaching(context.store) &&\n      this.knownResults.get(result) === selectionSet\n    ) {\n      const latest = this.executeSelectionSet.peek(\n        selectionSet,\n        parent,\n        context,\n        // If result is canonical, then it could only have been previously\n        // cached by the canonizing version of executeSelectionSet, so we can\n        // avoid checking both possibilities here.\n        this.canon.isKnown(result)\n      );\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    enclosingRef,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (\n      isReference(objectOrReference) &&\n      !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n      !context.store.has(objectOrReference.__ref)\n    ) {\n      return {\n        result: this.canon.empty,\n        missing: `Dangling reference to missing ${objectOrReference.__ref} object`,\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const typename = store.getFieldValue<string>(\n      objectOrReference,\n      \"__typename\"\n    );\n\n    const objectsToMerge: Record<string, any>[] = [];\n    let missing: MissingTree | undefined;\n    const missingMerger = new DeepMerger();\n\n    if (\n      this.config.addTypename &&\n      typeof typename === \"string\" &&\n      !policies.rootIdsByTypename[typename]\n    ) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function handleMissing<T>(result: ExecResult<T>, resultName: string): T {\n      if (result.missing) {\n        missing = missingMerger.merge(missing, {\n          [resultName]: result.missing,\n        });\n      }\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach((selection) => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField(\n          {\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference,\n          },\n          context\n        );\n\n        const resultName = resultKeyNameFromField(selection);\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            missing = missingMerger.merge(missing, {\n              [resultName]: `Can't find field '${selection.name.value}' on ${\n                isReference(objectOrReference)\n                  ? objectOrReference.__ref + \" object\"\n                  : \"object \" + JSON.stringify(objectOrReference, null, 2)\n              }`,\n            });\n          }\n        } else if (isArray(fieldValue)) {\n          fieldValue = handleMissing(\n            this.executeSubSelectedArray({\n              field: selection,\n              array: fieldValue,\n              enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. To keep this.canon from canonicalizing\n          // this value, we use this.canon.pass to wrap fieldValue in a\n          // Pass object that this.canon.admit will later unwrap as-is.\n          if (context.canonizeResults) {\n            fieldValue = this.canon.pass(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(\n            this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue as StoreObject | Reference,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context,\n            }),\n            resultName\n          );\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.lookupFragment\n        );\n\n        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n          throw newInvariantError(`No fragment named %s`, selection.name.value);\n        }\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    const result = mergeDeepArray(objectsToMerge);\n    const finalResult: ExecResult = { result, missing };\n    const frozen = context.canonizeResults\n      ? this.canon.admit(finalResult)\n      : // Since this.canon is normally responsible for freezing results (only in\n        // development), freeze them manually if canonization is disabled.\n        maybeDeepFreeze(finalResult);\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    if (frozen.result) {\n      this.knownResults.set(frozen.result, selectionSet);\n    }\n\n    return frozen;\n  }\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    enclosingRef,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingTree | undefined;\n    let missingMerger = new DeepMerger<MissingTree[]>();\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missingMerger.merge(missing, { [i]: childResult.missing });\n      }\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (isArray(item)) {\n        return handleMissing(\n          this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(\n          this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context,\n          }),\n          i\n        );\n      }\n\n      if (__DEV__) {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      return item;\n    });\n\n    return {\n      result: context.canonizeResults ? this.canon.admit(array) : array,\n      missing,\n    };\n  }\n}\n\nfunction firstMissing(tree: MissingTree): string | undefined {\n  try {\n    JSON.stringify(tree, (_, value) => {\n      if (typeof value === \"string\") throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach((value) => {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type %s returned for query field %s`,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n", "import type { OptimisticDependencyFunction } from \"optimism\";\nimport { dep } from \"optimism\";\nimport { Slot } from \"@wry/context\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { ApolloCache } from \"../../core/index.js\";\n\nexport interface ReactiveVar<T> {\n  (newValue?: T): T;\n  onNextChange(listener: ReactiveListener<T>): () => void;\n  attachCache(cache: ApolloCache<any>): this;\n  forgetCache(cache: ApolloCache<any>): boolean;\n}\n\nexport type ReactiveListener<T> = (value: T) => any;\n\n// Contextual Slot that acquires its value when custom read functions are\n// called in Policies#readField.\nexport const cacheSlot = new Slot<ApolloCache<any>>();\n\nconst cacheInfoMap = new WeakMap<\n  ApolloCache<any>,\n  {\n    vars: Set<ReactiveVar<any>>;\n    dep: OptimisticDependencyFunction<ReactiveVar<any>>;\n  }\n>();\n\nfunction getCacheInfo(cache: ApolloCache<any>) {\n  let info = cacheInfoMap.get(cache)!;\n  if (!info) {\n    cacheInfoMap.set(\n      cache,\n      (info = {\n        vars: new Set(),\n        dep: dep(),\n      })\n    );\n  }\n  return info;\n}\n\nexport function forgetCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.forgetCache(cache));\n}\n\n// Calling forgetCache(cache) serves to silence broadcasts and allows the\n// cache to be garbage collected. However, the varsByCache WeakMap\n// preserves the set of reactive variables that were previously associated\n// with this cache, which makes it possible to \"recall\" the cache at a\n// later time, by reattaching it to those variables. If the cache has been\n// garbage collected in the meantime, because it is no longer reachable,\n// you won't be able to call recallCache(cache), and the cache will\n// automatically disappear from the varsByCache WeakMap.\nexport function recallCache(cache: ApolloCache<any>) {\n  getCacheInfo(cache).vars.forEach((rv) => rv.attachCache(cache));\n}\n\nexport function makeVar<T>(value: T): ReactiveVar<T> {\n  const caches = new Set<ApolloCache<any>>();\n  const listeners = new Set<ReactiveListener<T>>();\n\n  const rv: ReactiveVar<T> = function (newValue) {\n    if (arguments.length > 0) {\n      if (value !== newValue) {\n        value = newValue!;\n        caches.forEach((cache) => {\n          // Invalidate any fields with custom read functions that\n          // consumed this variable, so query results involving those\n          // fields will be recomputed the next time we read them.\n          getCacheInfo(cache).dep.dirty(rv);\n          // Broadcast changes to any caches that have previously read\n          // from this variable.\n          broadcast(cache);\n        });\n        // Finally, notify any listeners added via rv.onNextChange.\n        const oldListeners = Array.from(listeners);\n        listeners.clear();\n        oldListeners.forEach((listener) => listener(value));\n      }\n    } else {\n      // When reading from the variable, obtain the current cache from\n      // context via cacheSlot. This isn't entirely foolproof, but it's\n      // the same system that powers varDep.\n      const cache = cacheSlot.getValue();\n      if (cache) {\n        attach(cache);\n        getCacheInfo(cache).dep(rv);\n      }\n    }\n\n    return value;\n  };\n\n  rv.onNextChange = (listener) => {\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n    };\n  };\n\n  const attach = (rv.attachCache = (cache) => {\n    caches.add(cache);\n    getCacheInfo(cache).vars.add(rv);\n    return rv;\n  });\n\n  rv.forgetCache = (cache) => caches.delete(cache);\n\n  return rv;\n}\n\ntype Broadcastable = ApolloCache<any> & {\n  // This method is protected in InMemoryCache, which we are ignoring, but\n  // we still want some semblance of type safety when we call it.\n  broadcastWatches?: InMemoryCache[\"broadcastWatches\"];\n};\n\nfunction broadcast(cache: Broadcastable) {\n  if (cache.broadcastWatches) {\n    cache.broadcastWatches();\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport {\n  argumentsObjectFromField,\n  DeepMerger,\n  isNonEmptyArray,\n  isNonNullObject,\n} from \"../../utilities/index.js\";\n\nimport { hasOwn, isArray } from \"./helpers.js\";\nimport type {\n  KeySpecifier,\n  KeyFieldsFunction,\n  KeyArgsFunction,\n} from \"./policies.js\";\n\n// Mapping from JSON-encoded KeySpecifier strings to associated information.\nconst specifierInfoCache: Record<\n  string,\n  {\n    paths?: string[][];\n    keyFieldsFn?: KeyFieldsFunction;\n    keyArgsFn?: KeyArgsFunction;\n  }\n> = Object.create(null);\n\nfunction lookupSpecifierInfo(spec: KeySpecifier) {\n  // It's safe to encode KeySpecifier arrays with JSON.stringify, since they're\n  // just arrays of strings or nested KeySpecifier arrays, and the order of the\n  // array elements is important (and suitably preserved by JSON.stringify).\n  const cacheKey = JSON.stringify(spec);\n  return (\n    specifierInfoCache[cacheKey] ||\n    (specifierInfoCache[cacheKey] = Object.create(null))\n  );\n}\n\nexport function keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyFieldsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyFieldsFn ||\n    (info.keyFieldsFn = (object, context) => {\n      const extract: typeof extractKey = (from, key) =>\n        context.readField(key, from);\n\n      const keyObject = (context.keyObject = collectSpecifierPaths(\n        specifier,\n        (schemaKeyPath) => {\n          let extracted = extractKeyPath(\n            context.storeObject,\n            schemaKeyPath,\n            // Using context.readField to extract paths from context.storeObject\n            // allows the extraction to see through Reference objects and respect\n            // custom read functions.\n            extract\n          );\n\n          if (\n            extracted === void 0 &&\n            object !== context.storeObject &&\n            hasOwn.call(object, schemaKeyPath[0])\n          ) {\n            // If context.storeObject fails to provide a value for the requested\n            // path, fall back to the raw result object, if it has a top-level key\n            // matching the first key in the path (schemaKeyPath[0]). This allows\n            // key fields included in the written data to be saved in the cache\n            // even if they are not selected explicitly in context.selectionSet.\n            // Not being mentioned by context.selectionSet is convenient here,\n            // since it means these extra fields cannot be affected by field\n            // aliasing, which is why we can use extractKey instead of\n            // context.readField for this extraction.\n            extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n          }\n\n          invariant(\n            extracted !== void 0,\n            `Missing field '%s' while extracting keyFields from %s`,\n            schemaKeyPath.join(\".\"),\n            object\n          );\n\n          return extracted;\n        }\n      ));\n\n      return `${context.typename}:${JSON.stringify(keyObject)}`;\n    })\n  );\n}\n\n// The keyArgs extraction process is roughly analogous to keyFields extraction,\n// but there are no aliases involved, missing fields are tolerated (by merely\n// omitting them from the key), and drawing from field.directives or variables\n// is allowed (in addition to drawing from the field's arguments object).\n// Concretely, these differences mean passing a different key path extractor\n// function to collectSpecifierPaths, reusing the shared extractKeyPath helper\n// wherever possible.\nexport function keyArgsFnFromSpecifier(\n  specifier: KeySpecifier\n): KeyArgsFunction {\n  const info = lookupSpecifierInfo(specifier);\n\n  return (\n    info.keyArgsFn ||\n    (info.keyArgsFn = (args, { field, variables, fieldName }) => {\n      const collected = collectSpecifierPaths(specifier, (keyPath) => {\n        const firstKey = keyPath[0];\n        const firstChar = firstKey.charAt(0);\n\n        if (firstChar === \"@\") {\n          if (field && isNonEmptyArray(field.directives)) {\n            const directiveName = firstKey.slice(1);\n            // If the directive appears multiple times, only the first\n            // occurrence's arguments will be used. TODO Allow repetition?\n            // TODO Cache this work somehow, a la aliasMap?\n            const d = field.directives.find(\n              (d) => d.name.value === directiveName\n            );\n            // Fortunately argumentsObjectFromField works for DirectiveNode!\n            const directiveArgs = d && argumentsObjectFromField(d, variables);\n            // For directives without arguments (d defined, but directiveArgs ===\n            // null), the presence or absence of the directive still counts as\n            // part of the field key, so we return null in those cases. If no\n            // directive with this name was found for this field (d undefined and\n            // thus directiveArgs undefined), we return undefined, which causes\n            // this value to be omitted from the key object returned by\n            // collectSpecifierPaths.\n            return (\n              directiveArgs &&\n              extractKeyPath(\n                directiveArgs,\n                // If keyPath.length === 1, this code calls extractKeyPath with an\n                // empty path, which works because it uses directiveArgs as the\n                // extracted value.\n                keyPath.slice(1)\n              )\n            );\n          }\n          // If the key started with @ but there was no corresponding directive,\n          // we want to omit this value from the key object, not fall through to\n          // treating @whatever as a normal argument name.\n          return;\n        }\n\n        if (firstChar === \"$\") {\n          const variableName = firstKey.slice(1);\n          if (variables && hasOwn.call(variables, variableName)) {\n            const varKeyPath = keyPath.slice(0);\n            varKeyPath[0] = variableName;\n            return extractKeyPath(variables, varKeyPath);\n          }\n          // If the key started with $ but there was no corresponding variable, we\n          // want to omit this value from the key object, not fall through to\n          // treating $whatever as a normal argument name.\n          return;\n        }\n\n        if (args) {\n          return extractKeyPath(args, keyPath);\n        }\n      });\n\n      const suffix = JSON.stringify(collected);\n\n      // If no arguments were passed to this field, and it didn't have any other\n      // field key contributions from directives or variables, hide the empty\n      // :{} suffix from the field key. However, a field passed no arguments can\n      // still end up with a non-empty :{...} suffix if its key configuration\n      // refers to directives or variables.\n      if (args || suffix !== \"{}\") {\n        fieldName += \":\" + suffix;\n      }\n\n      return fieldName;\n    })\n  );\n}\n\nexport function collectSpecifierPaths(\n  specifier: KeySpecifier,\n  extractor: (path: string[]) => any\n): Record<string, any> {\n  // For each path specified by specifier, invoke the extractor, and repeatedly\n  // merge the results together, with appropriate ancestor context.\n  const merger = new DeepMerger();\n  return getSpecifierPaths(specifier).reduce((collected, path) => {\n    let toMerge = extractor(path);\n    if (toMerge !== void 0) {\n      // This path is not expected to contain array indexes, so the toMerge\n      // reconstruction will not contain arrays. TODO Fix this?\n      for (let i = path.length - 1; i >= 0; --i) {\n        toMerge = { [path[i]]: toMerge };\n      }\n      collected = merger.merge(collected, toMerge);\n    }\n    return collected;\n  }, Object.create(null));\n}\n\nexport function getSpecifierPaths(spec: KeySpecifier): string[][] {\n  const info = lookupSpecifierInfo(spec);\n\n  if (!info.paths) {\n    const paths: string[][] = (info.paths = []);\n    const currentPath: string[] = [];\n\n    spec.forEach((s, i) => {\n      if (isArray(s)) {\n        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));\n        currentPath.length = 0;\n      } else {\n        currentPath.push(s);\n        if (!isArray(spec[i + 1])) {\n          paths.push(currentPath.slice(0));\n          currentPath.length = 0;\n        }\n      }\n    });\n  }\n\n  return info.paths!;\n}\n\nfunction extractKey<TObj extends Record<string, any>, TKey extends string>(\n  object: TObj,\n  key: TKey\n): TObj[TKey] | undefined {\n  return object[key];\n}\n\nexport function extractKeyPath(\n  object: Record<string, any>,\n  path: string[],\n  extract?: typeof extractKey\n): any {\n  // For each key in path, extract the corresponding child property from obj,\n  // flattening arrays if encountered (uncommon for keyFields and keyArgs, but\n  // possible). The final result of path.reduce is normalized so unexpected leaf\n  // objects have their keys safely sorted. That final result is difficult to\n  // type as anything other than any. You're welcome to try to improve the\n  // return type, but keep in mind extractKeyPath is not a public function\n  // (exported only for testing), so the effort may not be worthwhile unless the\n  // limited set of actual callers (see above) pass arguments that TypeScript\n  // can statically type. If we know only that path is some array of strings\n  // (and not, say, a specific tuple of statically known strings), any (or\n  // possibly unknown) is the honest answer.\n  extract = extract || extractKey;\n  return normalize(\n    path.reduce(function reducer(obj, key): any {\n      return isArray(obj)\n        ? obj.map((child) => reducer(child, key))\n        : obj && extract!(obj, key);\n    }, object)\n  );\n}\n\nfunction normalize<T>(value: T): T {\n  // Usually the extracted value will be a scalar value, since most primary\n  // key fields are scalar, but just in case we get an object or an array, we\n  // need to do some normalization of the order of (nested) keys.\n  if (isNonNullObject(value)) {\n    if (isArray(value)) {\n      return value.map(normalize) as any;\n    }\n    return collectSpecifierPaths(Object.keys(value).sort(), (path) =>\n      extractKeyPath(value, path)\n    ) as T;\n  }\n  return value;\n}\n", "import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\n\nimport type {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from \"graphql\";\n\nimport type {\n  FragmentMap,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  storeKeyNameFromField,\n  argumentsObjectFromField,\n  isReference,\n  getStoreKeyName,\n  isNonNullObject,\n  stringifyForDisplay,\n} from \"../../utilities/index.js\";\nimport type {\n  IdGetter,\n  MergeInfo,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from \"./types.js\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n  defaultDataIdFromObject,\n  isArray,\n} from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from \"../core/types/common.js\";\nimport type { WriteContext } from \"./writeToStore.js\";\n\n// Upgrade to a faster version of the default stable JSON.stringify function\n// used by getStoreKeyName. This function is used when computing storeFieldName\n// strings (when no keyArgs has been configured for a field).\nimport { canonicalStringify } from \"./object-canon.js\";\nimport {\n  keyArgsFnFromSpecifier,\n  keyFieldsFnFromSpecifier,\n} from \"./key-extractor.js\";\n\ngetStoreKeyName.setStringify(canonicalStringify);\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n};\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\nexport type KeySpecifier = ReadonlyArray<string | KeySpecifier>;\n\nexport type KeyFieldsContext = {\n  // The __typename of the incoming object, even if the __typename field was\n  // aliased to another name in the raw result object. May be undefined when\n  // dataIdFromObject is called for objects without __typename fields.\n  typename: string | undefined;\n\n  // The object to be identified, after processing to remove aliases and\n  // normalize identifiable child objects with references.\n  storeObject: StoreObject;\n\n  // Handy tool for reading additional fields from context.storeObject, either\n  // readField(\"fieldName\") to read storeObject[fieldName], or readField(\"name\",\n  // objectOrReference) to read from another object or Reference. If you read a\n  // field with a read function, that function will be invoked.\n  readField: ReadFieldFunction;\n\n  // If you are writing a custom keyFields function, and you plan to use the raw\n  // result object passed as the first argument, you may also need access to the\n  // selection set and available fragments for this object, just in case any\n  // fields have aliases. Since this logic is tricky to get right, and these\n  // context properties are not even always provided (for example, they are\n  // omitted when calling cache.identify(object), where object is assumed to be\n  // a StoreObject), we recommend you use context.storeObject (which has already\n  // been de-aliased) and context.readField (which can read from references as\n  // well as objects) instead of the raw result object in your keyFields\n  // functions, or just rely on the internal implementation of keyFields:[...]\n  // syntax to get these details right for you.\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n\n  // Internal. May be set by the KeyFieldsFunction to report fields that were\n  // involved in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\ntype KeyFieldsResult = Exclude<ReturnType<KeyFieldsFunction>, KeySpecifier>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true;\n  mutationType?: true;\n  subscriptionType?: true;\n\n  fields?: {\n    [fieldName: string]: FieldPolicy<any> | FieldReadFunction<any>;\n  };\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  }\n) => KeySpecifier | false | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n  // Allows FieldFunctionOptions definition to be overwritten by the\n  // developer\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult, TOptions>;\n  merge?: FieldMergeFunction<TExisting, TIncoming, TOptions> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return spec.args !== void 0\n    ? spec.args\n    : spec.field\n    ? argumentsObjectFromField(spec.field, spec.variables)\n    : null;\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T\n) => T;\n\nexport type FieldReadFunction<\n  TExisting = any,\n  TReadResult = TExisting,\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: TOptions\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<\n  TExisting = any,\n  TIncoming = TExisting,\n  // Passing the whole FieldFunctionOptions makes the current definition\n  // independent from its implementation\n  TOptions extends FieldFunctionOptions = FieldFunctionOptions,\n> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: TOptions\n) => SafeReadonly<TExisting>;\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> = (\n  existing,\n  incoming,\n  { mergeObjects }\n) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> =\n    Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> =\n    Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(\n    private config: {\n      cache: InMemoryCache;\n      dataIdFromObject?: KeyFieldsFunction;\n      possibleTypes?: PossibleTypesMap;\n      typePolicies?: TypePolicies;\n    }\n  ) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    partialContext?: Partial<KeyFieldsContext>\n  ): [string?, StoreObject?] {\n    const policies = this;\n\n    const typename =\n      (partialContext &&\n        (partialContext.typename || partialContext.storeObject?.__typename)) ||\n      object.__typename;\n\n    // It should be possible to write root Query fields with writeFragment,\n    // using { __typename: \"Query\", ... } as the data, but it does not make\n    // sense to allow the same identification behavior for the Mutation and\n    // Subscription types, since application code should never be writing\n    // directly to (or reading directly from) those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    // Default context.storeObject to object if not otherwise provided.\n    const storeObject =\n      (partialContext && partialContext.storeObject) || object;\n\n    const context: KeyFieldsContext = {\n      ...partialContext,\n      typename,\n      storeObject,\n      readField:\n        (partialContext && partialContext.readField) ||\n        function () {\n          const options = normalizeReadFieldOptions(arguments, storeObject);\n          return policies.readField(options, {\n            store: policies.cache[\"data\"],\n            variables: options.variables,\n          });\n        },\n    };\n\n    let id: KeyFieldsResult;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n    while (keyFn) {\n      const specifierOrId = keyFn({ ...object, ...storeObject }, context);\n      if (isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id ? String(id) : void 0;\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach((typename) => {\n      const { queryType, mutationType, subscriptionType, ...incoming } =\n        typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(typename: string, incoming: TypePolicy) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean },\n      merge?: FieldMergeFunction | boolean\n    ) {\n      existing.merge =\n        typeof merge === \"function\"\n          ? merge\n          : // Pass merge:true as a shorthand for a merge implementation\n          // that returns options.mergeObjects(existing, incoming).\n          merge === true\n          ? mergeTrueFn\n          : // Pass merge:false to make incoming always replace existing\n          // without any warnings about data clobbering.\n          merge === false\n          ? mergeFalseFn\n          : existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false\n        ? nullKeyFieldsFn\n        : // Pass an array of strings to use those fields to compute a\n        // composite ID for objects of this typename.\n        isArray(keyFields)\n        ? keyFieldsFnFromSpecifier(keyFields)\n        : // Pass a function to take full control over identification.\n        typeof keyFields === \"function\"\n        ? keyFields\n        : // Leave existing.keyFn unchanged if above cases fail.\n          existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach((fieldName) => {\n        const existing = this.getFieldPolicy(typename, fieldName, true)!;\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false\n              ? simpleKeyArgsFn\n              : // Pass an array of strings to use named arguments to\n              // compute a composite identity for the field.\n              isArray(keyArgs)\n              ? keyArgsFnFromSpecifier(keyArgs)\n              : // Pass a function to take full control over field identity.\n              typeof keyArgs === \"function\"\n              ? keyArgs\n              : // Leave existing.keyFn unchanged if above cases fail.\n                existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(\n        !old || old === which,\n        `Cannot change root %s __typename more than once`,\n        which\n      );\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach((supertype) => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach((subtype) => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] = (this.typePolicies[\n        typename\n      ] = Object.create(null));\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its properties can\n      // still be updated directly using addTypePolicies, but future changes to\n      // inherited supertype policies will not be reflected in this subtype\n      // policy, because this code runs at most once per typename.\n      let supertypes = this.supertypeMap.get(typename);\n      if (!supertypes && this.fuzzySubtypes.size) {\n        // To make the inheritance logic work for unknown typename strings that\n        // may have fuzzy supertypes, we give this typename an empty supertype\n        // set and then populate it with any fuzzy supertypes that match.\n        supertypes = this.getSupertypeSet(typename, true)!;\n        // This only works for typenames that are directly matched by a fuzzy\n        // supertype. What if there is an intermediate chain of supertypes?\n        // While possible, that situation can only be solved effectively by\n        // specifying the intermediate relationships via possibleTypes, manually\n        // and in a non-fuzzy way.\n        this.fuzzySubtypes.forEach((regExp, fuzzy) => {\n          if (regExp.test(typename)) {\n            // The fuzzy parameter is just the original string version of regExp\n            // (not a valid __typename string), but we can look up the\n            // associated supertype(s) in this.supertypeMap.\n            const fuzzySupertypes = this.supertypeMap.get(fuzzy);\n            if (fuzzySupertypes) {\n              fuzzySupertypes.forEach((supertype) =>\n                supertypes!.add(supertype)\n              );\n            }\n          }\n        });\n      }\n      if (supertypes && supertypes.size) {\n        supertypes.forEach((supertype) => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      // Merge the pending policies into this.typePolicies, in the order they\n      // were originally passed to addTypePolicy.\n      inbox.splice(0).forEach((policy) => {\n        this.updateTypePolicy(typename, policy);\n      });\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean\n  ):\n    | {\n        keyFn?: KeyArgsFunction;\n        read?: FieldReadFunction<any>;\n        merge?: FieldMergeFunction<any>;\n      }\n    | undefined {\n    if (typename) {\n      const fieldPolicies = this.getTypePolicy(typename).fields;\n      return (\n        fieldPolicies[fieldName] ||\n        (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)))\n      );\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, (supertypeSet = new Set<string>()));\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (\n          supertypeSet &&\n          supertypeSet.size &&\n          workQueue.indexOf(supertypeSet) < 0\n        ) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(\n                `Inferring subtype %s of supertype %s`,\n                typename,\n                supertype\n              );\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (\n          needToCheckFuzzySubtypes &&\n          // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue.length - 1 &&\n          // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result!, variables)\n        ) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: Exclude<ReturnType<KeyArgsFunction>, KeySpecifier>;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field\n        ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Returning false from a keyArgs function is like configuring\n    // keyArgs: false, but more dynamic.\n    if (storeFieldName === false) {\n      return fieldName;\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName)\n      ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(\n        objectOrReference,\n        \"__typename\"\n      );\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(\n      objectOrReference,\n      storeFieldName\n    );\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference)\n            ? objectOrReference.__ref\n            : objectOrReference,\n          storeFieldName\n        )\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(this.cache, read, [\n        existing,\n        readOptions,\n      ]) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getReadFunction(\n    typename: string | undefined,\n    fieldName: string\n  ): FieldReadFunction | undefined {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return policy && policy.read;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined = this.getFieldPolicy(parentTypename, fieldName, false);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: WriteContext,\n    storage?: StorageType\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(context.store)(\n        existing as StoreObject,\n        incoming as StoreObject\n      );\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    // If cache.writeQuery or cache.writeFragment was called with\n    // options.overwrite set to true, we still call merge functions, but\n    // the existing data is always undefined, so the merge function will\n    // not attempt to combine the incoming data with the existing data.\n    if (context.overwrite) {\n      existing = void 0;\n    }\n\n    return merge(\n      existing,\n      incoming,\n      makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        },\n        context,\n        storage || Object.create(null)\n      )\n    );\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField<T>() {\n      return policies.readField<T>(\n        normalizeReadFieldOptions(arguments, objectOrReference, variables),\n        context\n      );\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store),\n  };\n}\n\nexport function normalizeReadFieldOptions(\n  readFieldArgs: IArguments,\n  objectOrReference: StoreObject | Reference | undefined,\n  variables?: ReadMergeModifyContext[\"variables\"]\n): ReadFieldOptions {\n  const { 0: fieldNameOrOptions, 1: from, length: argc } = readFieldArgs;\n\n  let options: ReadFieldOptions;\n\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference,\n    };\n  } else {\n    options = { ...fieldNameOrOptions };\n    // Default to objectOrReference only when fieldNameOrOptions.from is\n    // actually omitted, rather than just undefined.\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n\n  if (__DEV__ && options.from === void 0) {\n    invariant.warn(\n      `Undefined 'from' passed to readField with arguments %s`,\n      stringifyForDisplay(Array.from(readFieldArgs))\n    );\n  }\n\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n\n  return options;\n}\n\nfunction makeMergeObjectsFunction(\n  store: NormalizedCache\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      const eType = store.getFieldValue(existing, \"__typename\");\n      const iType = store.getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer) {\n        return incoming;\n      }\n\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // existing.__ref, preferring/overwriting any fields contributed by the\n        // newer incoming StoreObject.\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        // Update the normalized EntityStore for the entity identified by\n        // incoming.__ref, taking fields from the older existing object only if\n        // those fields are not already present in the newer StoreObject\n        // identified by incoming.__ref.\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n\n      if (\n        storeValueIsStoreObject(existing) &&\n        storeValueIsStoreObject(incoming)\n      ) {\n        return { ...existing, ...incoming };\n      }\n    }\n\n    return incoming;\n  };\n}\n", "import { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport type { SelectionSetNode, FieldNode } from \"graphql\";\nimport { Kind } from \"graphql\";\n\nimport type {\n  FragmentMap,\n  FragmentMapFunction,\n  StoreValue,\n  StoreObject,\n  Reference,\n} from \"../../utilities/index.js\";\nimport {\n  getFragmentFromSelection,\n  getDefaultValues,\n  getOperationDefinition,\n  getTypenameFromResult,\n  makeReference,\n  isField,\n  resultKeyNameFromField,\n  isReference,\n  shouldInclude,\n  cloneDeep,\n  addTypenameToDocument,\n  isNonEmptyArray,\n  argumentsObjectFromField,\n} from \"../../utilities/index.js\";\n\nimport type {\n  NormalizedCache,\n  ReadMergeModifyContext,\n  MergeTree,\n  InMemoryCacheConfig,\n} from \"./types.js\";\nimport {\n  isArray,\n  makeProcessedFieldsMerger,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  extractFragmentContext,\n} from \"./helpers.js\";\nimport type { StoreReader } from \"./readFromStore.js\";\nimport type { InMemoryCache } from \"./inMemoryCache.js\";\nimport type { EntityStore } from \"./entityStore.js\";\nimport type { Cache } from \"../../core/index.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\nimport type { ReadFieldFunction } from \"../core/types/common.js\";\n\nexport interface WriteContext extends ReadMergeModifyContext {\n  readonly written: {\n    [dataId: string]: SelectionSetNode[];\n  };\n  readonly fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n  // General-purpose deep-merge function for use during writes.\n  merge<T>(existing: T, incoming: T): T;\n  // If true, merge functions will be called with undefined existing data.\n  overwrite: boolean;\n  incomingById: Map<\n    string,\n    {\n      storeObject: StoreObject;\n      mergeTree?: MergeTree;\n      fieldNodeSet: Set<FieldNode>;\n    }\n  >;\n  // Directive metadata for @client and @defer. We could use a bitfield for this\n  // information to save some space, and use that bitfield number as the keys in\n  // the context.flavors Map.\n  clientOnly: boolean;\n  deferred: boolean;\n  flavors: Map<string, FlavorableWriteContext>;\n}\n\ntype FlavorableWriteContext = Pick<\n  WriteContext,\n  \"clientOnly\" | \"deferred\" | \"flavors\"\n>;\n\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor<TContext extends FlavorableWriteContext>(\n  context: TContext,\n  clientOnly: TContext[\"clientOnly\"],\n  deferred: TContext[\"deferred\"]\n): TContext {\n  const key = `${clientOnly}${deferred}`;\n  let flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(\n      key,\n      (flavored =\n        context.clientOnly === clientOnly && context.deferred === deferred\n          ? context\n          : {\n              ...context,\n              clientOnly,\n              deferred,\n            })\n    );\n  }\n  return flavored as TContext;\n}\n\ninterface ProcessSelectionSetOptions {\n  dataId?: string;\n  result: Record<string, any>;\n  selectionSet: SelectionSetNode;\n  context: WriteContext;\n  mergeTree: MergeTree;\n}\n\nexport class StoreWriter {\n  constructor(\n    public readonly cache: InMemoryCache,\n    private reader?: StoreReader,\n    private fragments?: InMemoryCacheConfig[\"fragments\"]\n  ) {}\n\n  public writeToStore(\n    store: NormalizedCache,\n    { query, result, dataId, variables, overwrite }: Cache.WriteOptions\n  ): Reference | undefined {\n    const operationDefinition = getOperationDefinition(query)!;\n    const merger = makeProcessedFieldsMerger();\n\n    variables = {\n      ...getDefaultValues(operationDefinition),\n      ...variables!,\n    };\n\n    const context: WriteContext = {\n      store,\n      written: Object.create(null),\n      merge<T>(existing: T, incoming: T) {\n        return merger.merge(existing, incoming) as T;\n      },\n      variables,\n      varString: canonicalStringify(variables),\n      ...extractFragmentContext(query, this.fragments),\n      overwrite: !!overwrite,\n      incomingById: new Map(),\n      clientOnly: false,\n      deferred: false,\n      flavors: new Map(),\n    };\n\n    const ref = this.processSelectionSet({\n      result: result || Object.create(null),\n      dataId,\n      selectionSet: operationDefinition.selectionSet,\n      mergeTree: { map: new Map() },\n      context,\n    });\n\n    if (!isReference(ref)) {\n      throw newInvariantError(`Could not identify object %s`, result);\n    }\n\n    // So far, the store has not been modified, so now it's time to process\n    // context.incomingById and merge those incoming fields into context.store.\n    context.incomingById.forEach(\n      ({ storeObject, mergeTree, fieldNodeSet }, dataId) => {\n        const entityRef = makeReference(dataId);\n\n        if (mergeTree && mergeTree.map.size) {\n          const applied = this.applyMerges(\n            mergeTree,\n            entityRef,\n            storeObject,\n            context\n          );\n          if (isReference(applied)) {\n            // Assume References returned by applyMerges have already been merged\n            // into the store. See makeMergeObjectsFunction in policies.ts for an\n            // example of how this can happen.\n            return;\n          }\n          // Otherwise, applyMerges returned a StoreObject, whose fields we should\n          // merge into the store (see store.merge statement below).\n          storeObject = applied;\n        }\n\n        if (__DEV__ && !context.overwrite) {\n          const fieldsWithSelectionSets: Record<string, true> =\n            Object.create(null);\n          fieldNodeSet.forEach((field) => {\n            if (field.selectionSet) {\n              fieldsWithSelectionSets[field.name.value] = true;\n            }\n          });\n\n          const hasSelectionSet = (storeFieldName: string) =>\n            fieldsWithSelectionSets[fieldNameFromStoreName(storeFieldName)] ===\n            true;\n\n          const hasMergeFunction = (storeFieldName: string) => {\n            const childTree = mergeTree && mergeTree.map.get(storeFieldName);\n            return Boolean(childTree && childTree.info && childTree.info.merge);\n          };\n\n          Object.keys(storeObject).forEach((storeFieldName) => {\n            // If a merge function was defined for this field, trust that it\n            // did the right thing about (not) clobbering data. If the field\n            // has no selection set, it's a scalar field, so it doesn't need\n            // a merge function (even if it's an object, like JSON data).\n            if (\n              hasSelectionSet(storeFieldName) &&\n              !hasMergeFunction(storeFieldName)\n            ) {\n              warnAboutDataLoss(\n                entityRef,\n                storeObject,\n                storeFieldName,\n                context.store\n              );\n            }\n          });\n        }\n\n        store.merge(dataId, storeObject);\n      }\n    );\n\n    // Any IDs written explicitly to the cache will be retained as\n    // reachable root IDs for garbage collection purposes. Although this\n    // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n    // retainment counts are effectively ignored because cache.gc() always\n    // includes them in its root ID set.\n    store.retain(ref.__ref);\n\n    return ref;\n  }\n\n  private processSelectionSet({\n    dataId,\n    result,\n    selectionSet,\n    context,\n    // This object allows processSelectionSet to report useful information\n    // to its callers without explicitly returning that information.\n    mergeTree,\n  }: ProcessSelectionSetOptions): StoreObject | Reference {\n    const { policies } = this.cache;\n\n    // This variable will be repeatedly updated using context.merge to\n    // accumulate all fields that need to be written into the store.\n    let incoming: StoreObject = Object.create(null);\n\n    // If typename was not passed in, infer it. Note that typename is\n    // always passed in for tricky-to-infer cases such as \"Query\" for\n    // ROOT_QUERY.\n    const typename: string | undefined =\n      (dataId && policies.rootTypenamesById[dataId]) ||\n      getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n      (dataId && (context.store.get(dataId, \"__typename\") as string));\n\n    if (\"string\" === typeof typename) {\n      incoming.__typename = typename;\n    }\n\n    // This readField function will be passed as context.readField in the\n    // KeyFieldsContext object created within policies.identify (called below).\n    // In addition to reading from the existing context.store (thanks to the\n    // policies.readField(options, context) line at the very bottom), this\n    // version of readField can read from Reference objects that are currently\n    // pending in context.incomingById, which is important whenever keyFields\n    // need to be extracted from a child object that processSelectionSet has\n    // turned into a Reference.\n    const readField: ReadFieldFunction = function (this: void) {\n      const options = normalizeReadFieldOptions(\n        arguments,\n        incoming,\n        context.variables\n      );\n\n      if (isReference(options.from)) {\n        const info = context.incomingById.get(options.from.__ref);\n        if (info) {\n          const result = policies.readField(\n            {\n              ...options,\n              from: info.storeObject,\n            },\n            context\n          );\n\n          if (result !== void 0) {\n            return result;\n          }\n        }\n      }\n\n      return policies.readField(options, context);\n    };\n\n    const fieldNodeSet = new Set<FieldNode>();\n\n    this.flattenFields(\n      selectionSet,\n      result,\n      // This WriteContext will be the default context value for fields returned\n      // by the flattenFields method, but some fields may be assigned a modified\n      // context, depending on the presence of @client and other directives.\n      context,\n      typename\n    ).forEach((context, field) => {\n      const resultFieldKey = resultKeyNameFromField(field);\n      const value = result[resultFieldKey];\n\n      fieldNodeSet.add(field);\n\n      if (value !== void 0) {\n        const storeFieldName = policies.getStoreFieldName({\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables,\n        });\n\n        const childTree = getChildMergeTree(mergeTree, storeFieldName);\n\n        let incomingValue = this.processFieldValue(\n          value,\n          field,\n          // Reset context.clientOnly and context.deferred to their default\n          // values before processing nested selection sets.\n          field.selectionSet\n            ? getContextFlavor(context, false, false)\n            : context,\n          childTree\n        );\n\n        // To determine if this field holds a child object with a merge function\n        // defined in its type policy (see PR #7070), we need to figure out the\n        // child object's __typename.\n        let childTypename: string | undefined;\n\n        // The field's value can be an object that has a __typename only if the\n        // field has a selection set. Otherwise incomingValue is scalar.\n        if (\n          field.selectionSet &&\n          (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))\n        ) {\n          childTypename = readField<string>(\"__typename\", incomingValue);\n        }\n\n        const merge = policies.getMergeFunction(\n          typename,\n          field.name.value,\n          childTypename\n        );\n\n        if (merge) {\n          childTree.info = {\n            // TODO Check compatibility against any existing childTree.field?\n            field,\n            typename,\n            merge,\n          };\n        } else {\n          maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n        }\n\n        incoming = context.merge(incoming, {\n          [storeFieldName]: incomingValue,\n        });\n      } else if (\n        __DEV__ &&\n        !context.clientOnly &&\n        !context.deferred &&\n        !addTypenameToDocument.added(field) &&\n        // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)\n      ) {\n        invariant.error(\n          `Missing field '%s' while writing result %o`,\n          resultKeyNameFromField(field),\n          result\n        );\n      }\n    });\n\n    // Identify the result object, even if dataId was already provided,\n    // since we always need keyObject below.\n    try {\n      const [id, keyObject] = policies.identify(result, {\n        typename,\n        selectionSet,\n        fragmentMap: context.fragmentMap,\n        storeObject: incoming,\n        readField,\n      });\n\n      // If dataId was not provided, fall back to the id just generated by\n      // policies.identify.\n      dataId = dataId || id;\n\n      // Write any key fields that were used during identification, even if\n      // they were not mentioned in the original query.\n      if (keyObject) {\n        // TODO Reverse the order of the arguments?\n        incoming = context.merge(incoming, keyObject);\n      }\n    } catch (e) {\n      // If dataId was provided, tolerate failure of policies.identify.\n      if (!dataId) throw e;\n    }\n\n    if (\"string\" === typeof dataId) {\n      const dataRef = makeReference(dataId);\n\n      // Avoid processing the same entity object using the same selection\n      // set more than once. We use an array instead of a Set since most\n      // entity IDs will be written using only one selection set, so the\n      // size of this array is likely to be very small, meaning indexOf is\n      // likely to be faster than Set.prototype.has.\n      const sets = context.written[dataId] || (context.written[dataId] = []);\n      if (sets.indexOf(selectionSet) >= 0) return dataRef;\n      sets.push(selectionSet);\n\n      // If we're about to write a result object into the store, but we\n      // happen to know that the exact same (===) result object would be\n      // returned if we were to reread the result with the same inputs,\n      // then we can skip the rest of the processSelectionSet work for\n      // this object, and immediately return a Reference to it.\n      if (\n        this.reader &&\n        this.reader.isFresh(result, dataRef, selectionSet, context)\n      ) {\n        return dataRef;\n      }\n\n      const previous = context.incomingById.get(dataId);\n      if (previous) {\n        previous.storeObject = context.merge(previous.storeObject, incoming);\n        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);\n        fieldNodeSet.forEach((field) => previous.fieldNodeSet.add(field));\n      } else {\n        context.incomingById.set(dataId, {\n          storeObject: incoming,\n          // Save a reference to mergeTree only if it is not empty, because\n          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n          // reused for entirely different parts of the result tree.\n          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n          fieldNodeSet,\n        });\n      }\n\n      return dataRef;\n    }\n\n    return incoming;\n  }\n\n  private processFieldValue(\n    value: any,\n    field: FieldNode,\n    context: WriteContext,\n    mergeTree: MergeTree\n  ): StoreValue {\n    if (!field.selectionSet || value === null) {\n      // In development, we need to clone scalar values so that they can be\n      // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n      // it's cheaper to store the scalar values directly in the cache.\n      return __DEV__ ? cloneDeep(value) : value;\n    }\n\n    if (isArray(value)) {\n      return value.map((item, i) => {\n        const value = this.processFieldValue(\n          item,\n          field,\n          context,\n          getChildMergeTree(mergeTree, i)\n        );\n        maybeRecycleChildMergeTree(mergeTree, i);\n        return value;\n      });\n    }\n\n    return this.processSelectionSet({\n      result: value,\n      selectionSet: field.selectionSet,\n      context,\n      mergeTree,\n    });\n  }\n\n  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n  // some additions for tracking @client and @defer directives.\n  private flattenFields<\n    TContext extends Pick<\n      WriteContext,\n      | \"clientOnly\"\n      | \"deferred\"\n      | \"flavors\"\n      | \"fragmentMap\"\n      | \"lookupFragment\"\n      | \"variables\"\n    >,\n  >(\n    selectionSet: SelectionSetNode,\n    result: Record<string, any>,\n    context: TContext,\n    typename = getTypenameFromResult(result, selectionSet, context.fragmentMap)\n  ): Map<FieldNode, TContext> {\n    const fieldMap = new Map<FieldNode, TContext>();\n    const { policies } = this.cache;\n\n    const limitingTrie = new Trie<{\n      // Tracks whether (selectionSet, clientOnly, deferred) has been flattened\n      // before. The GraphQL specification only uses the fragment name for\n      // skipping previously visited fragments, but the top-level fragment\n      // selection set corresponds 1:1 with the fagment name (and is slightly\n      // easier too work with), and we need to consider clientOnly and deferred\n      // values as well, potentially revisiting selection sets that were\n      // previously visited with different inherited configurations of those\n      // directives.\n      visited?: boolean;\n    }>(false); // No need for WeakMap, since limitingTrie does not escape.\n\n    (function flatten(\n      this: void,\n      selectionSet: SelectionSetNode,\n      inheritedContext: TContext\n    ) {\n      const visitedNode = limitingTrie.lookup(\n        selectionSet,\n        // Because we take inheritedClientOnly and inheritedDeferred into\n        // consideration here (in addition to selectionSet), it's possible for\n        // the same selection set to be flattened more than once, if it appears\n        // in the query with different @client and/or @directive configurations.\n        inheritedContext.clientOnly,\n        inheritedContext.deferred\n      );\n      if (visitedNode.visited) return;\n      visitedNode.visited = true;\n\n      selectionSet.selections.forEach((selection) => {\n        if (!shouldInclude(selection, context.variables)) return;\n\n        let { clientOnly, deferred } = inheritedContext;\n        if (\n          // Since the presence of @client or @defer on this field can only\n          // cause clientOnly or deferred to become true, we can skip the\n          // forEach loop if both clientOnly and deferred are already true.\n          !(clientOnly && deferred) &&\n          isNonEmptyArray(selection.directives)\n        ) {\n          selection.directives.forEach((dir) => {\n            const name = dir.name.value;\n            if (name === \"client\") clientOnly = true;\n            if (name === \"defer\") {\n              const args = argumentsObjectFromField(dir, context.variables);\n              // The @defer directive takes an optional args.if boolean\n              // argument, similar to @include(if: boolean). Note that\n              // @defer(if: false) does not make context.deferred false, but\n              // instead behaves as if there was no @defer directive.\n              if (!args || (args as { if?: boolean }).if !== false) {\n                deferred = true;\n              }\n              // TODO In the future, we may want to record args.label using\n              // context.deferred, if a label is specified.\n            }\n          });\n        }\n\n        if (isField(selection)) {\n          const existing = fieldMap.get(selection);\n          if (existing) {\n            // If this field has been visited along another recursive path\n            // before, the final context should have clientOnly or deferred set\n            // to true only if *all* paths have the directive (hence the &&).\n            clientOnly = clientOnly && existing.clientOnly;\n            deferred = deferred && existing.deferred;\n          }\n\n          fieldMap.set(\n            selection,\n            getContextFlavor(context, clientOnly, deferred)\n          );\n        } else {\n          const fragment = getFragmentFromSelection(\n            selection,\n            context.lookupFragment\n          );\n\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(\n              `No fragment named %s`,\n              selection.name.value\n            );\n          }\n\n          if (\n            fragment &&\n            policies.fragmentMatches(\n              fragment,\n              typename,\n              result,\n              context.variables\n            )\n          ) {\n            flatten(\n              fragment.selectionSet,\n              getContextFlavor(context, clientOnly, deferred)\n            );\n          }\n        }\n      });\n    })(selectionSet, context);\n\n    return fieldMap;\n  }\n\n  private applyMerges<T extends StoreValue>(\n    mergeTree: MergeTree,\n    existing: StoreValue,\n    incoming: T,\n    context: WriteContext,\n    getStorageArgs?: Parameters<EntityStore[\"getStorage\"]>\n  ): T | Reference {\n    if (mergeTree.map.size && !isReference(incoming)) {\n      const e: StoreObject | Reference | undefined =\n        // Items in the same position in different arrays are not\n        // necessarily related to each other, so when incoming is an array\n        // we process its elements as if there was no existing data.\n        !isArray(incoming) &&\n        // Likewise, existing must be either a Reference or a StoreObject\n        // in order for its fields to be safe to merge with the fields of\n        // the incoming object.\n        (isReference(existing) || storeValueIsStoreObject(existing))\n          ? existing\n          : void 0;\n\n      // This narrowing is implied by mergeTree.map.size > 0 and\n      // !isReference(incoming), though TypeScript understandably cannot\n      // hope to infer this type.\n      const i = incoming as StoreObject | StoreValue[];\n\n      // The options.storage objects provided to read and merge functions\n      // are derived from the identity of the parent object plus a\n      // sequence of storeFieldName strings/numbers identifying the nested\n      // field name path of each field value to be merged.\n      if (e && !getStorageArgs) {\n        getStorageArgs = [isReference(e) ? e.__ref : e];\n      }\n\n      // It's possible that applying merge functions to this subtree will\n      // not change the incoming data, so this variable tracks the fields\n      // that did change, so we can create a new incoming object when (and\n      // only when) at least one incoming field has changed. We use a Map\n      // to preserve the type of numeric keys.\n      let changedFields: Map<string | number, StoreValue> | undefined;\n\n      const getValue = (\n        from: typeof e | typeof i,\n        name: string | number\n      ): StoreValue => {\n        return isArray(from)\n          ? typeof name === \"number\"\n            ? from[name]\n            : void 0\n          : context.store.getFieldValue(from, String(name));\n      };\n\n      mergeTree.map.forEach((childTree, storeFieldName) => {\n        const eVal = getValue(e, storeFieldName);\n        const iVal = getValue(i, storeFieldName);\n        // If we have no incoming data, leave any existing data untouched.\n        if (void 0 === iVal) return;\n        if (getStorageArgs) {\n          getStorageArgs.push(storeFieldName);\n        }\n        const aVal = this.applyMerges(\n          childTree,\n          eVal,\n          iVal,\n          context,\n          getStorageArgs\n        );\n        if (aVal !== iVal) {\n          changedFields = changedFields || new Map();\n          changedFields.set(storeFieldName, aVal);\n        }\n        if (getStorageArgs) {\n          invariant(getStorageArgs.pop() === storeFieldName);\n        }\n      });\n\n      if (changedFields) {\n        // Shallow clone i so we can add changed fields to it.\n        incoming = (isArray(i) ? i.slice(0) : { ...i }) as T;\n        changedFields.forEach((value, name) => {\n          (incoming as any)[name] = value;\n        });\n      }\n    }\n\n    if (mergeTree.info) {\n      return this.cache.policies.runMergeFunction(\n        existing,\n        incoming,\n        mergeTree.info,\n        context,\n        getStorageArgs && context.store.getStorage(...getStorageArgs)\n      );\n    }\n\n    return incoming;\n  }\n}\n\nconst emptyMergeTreePool: MergeTree[] = [];\n\nfunction getChildMergeTree(\n  { map }: MergeTree,\n  name: string | number\n): MergeTree {\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n  }\n  return map.get(name)!;\n}\n\nfunction mergeMergeTrees(\n  left: MergeTree | undefined,\n  right: MergeTree | undefined\n): MergeTree {\n  if (left === right || !right || mergeTreeIsEmpty(right)) return left!;\n  if (!left || mergeTreeIsEmpty(left)) return right;\n\n  const info =\n    left.info && right.info\n      ? {\n          ...left.info,\n          ...right.info,\n        }\n      : left.info || right.info;\n\n  const needToMergeMaps = left.map.size && right.map.size;\n  const map = needToMergeMaps\n    ? new Map()\n    : left.map.size\n    ? left.map\n    : right.map;\n\n  const merged = { info, map };\n\n  if (needToMergeMaps) {\n    const remainingRightKeys = new Set(right.map.keys());\n\n    left.map.forEach((leftTree, key) => {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys.delete(key);\n    });\n\n    remainingRightKeys.forEach((key) => {\n      merged.map.set(\n        key,\n        mergeMergeTrees(right.map.get(key), left.map.get(key))\n      );\n    });\n  }\n\n  return merged;\n}\n\nfunction mergeTreeIsEmpty(tree: MergeTree | undefined): boolean {\n  return !tree || !(tree.info || tree.map.size);\n}\n\nfunction maybeRecycleChildMergeTree({ map }: MergeTree, name: string | number) {\n  const childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\n\nconst warnings = new Set<string>();\n\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(\n  existingRef: Reference,\n  incomingObj: StoreObject,\n  storeFieldName: string,\n  store: NormalizedCache\n) {\n  const getChild = (objOrRef: StoreObject | Reference): StoreObject | false => {\n    const child = store.getFieldValue<StoreObject>(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n\n  const existing = getChild(existingRef);\n  if (!existing) return;\n\n  const incoming = getChild(incomingObj);\n  if (!incoming) return;\n\n  // It's always safe to replace a reference, since it refers to data\n  // safely stored elsewhere.\n  if (isReference(existing)) return;\n\n  // If the values are structurally equivalent, we do not need to worry\n  // about incoming replacing existing.\n  if (equal(existing, incoming)) return;\n\n  // If we're replacing every key of the existing object, then the\n  // existing data would be overwritten even if the objects were\n  // normalized, so warning would not be helpful here.\n  if (\n    Object.keys(existing).every(\n      (key) => store.getFieldValue(incoming, key) !== void 0\n    )\n  ) {\n    return;\n  }\n\n  const parentType =\n    store.getFieldValue<string>(existingRef, \"__typename\") ||\n    store.getFieldValue<string>(incomingObj, \"__typename\");\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const typeDotName = `${parentType}.${fieldName}`;\n  // Avoid warning more than once for the same type and field name.\n  if (warnings.has(typeDotName)) return;\n  warnings.add(typeDotName);\n\n  const childTypenames: string[] = [];\n  // Arrays do not have __typename fields, and always need a custom merge\n  // function, even if their elements are normalized entities.\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach((child) => {\n      const typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n\n  invariant.warn(\n    `Cache data may be lost when replacing the %s field of a %s object.\n\nThis could cause additional (usually avoidable) network requests to fetch data that were otherwise cached.\n\nTo address this problem (which is not a bug in Apollo Client), %sdefine a custom merge function for the %s field, so InMemoryCache can safely merge these objects:\n\n  existing: %s\n  incoming: %s\n\nFor more information about these options, please refer to the documentation:\n\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\n`,\n    fieldName,\n    parentType,\n    childTypenames.length\n      ? \"either ensure all objects of type \" +\n          childTypenames.join(\" and \") +\n          \" have an ID or a custom merge function, or \"\n      : \"\",\n    typeDotName,\n    existing,\n    incoming\n  );\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\n// Make builtins like Map and Set safe to use with non-extensible objects.\nimport \"./fixPolyfills.js\";\n\nimport type { DocumentNode } from \"graphql\";\nimport type { OptimisticWrapperFunction } from \"optimism\";\nimport { wrap } from \"optimism\";\nimport { equal } from \"@wry/equality\";\n\nimport { ApolloCache } from \"../core/cache.js\";\nimport type { Cache } from \"../core/types/Cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport type { StoreObject, Reference } from \"../../utilities/index.js\";\nimport {\n  addTypenameToDocument,\n  isReference,\n  DocumentTransform,\n} from \"../../utilities/index.js\";\nimport type { InMemoryCacheConfig, NormalizedCacheObject } from \"./types.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache, recallCache } from \"./reactiveVars.js\";\nimport { Policies } from \"./policies.js\";\nimport { hasOwn, normalizeConfig, shouldCanonizeResults } from \"./helpers.js\";\nimport { canonicalStringify } from \"./object-canon.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\n\ntype BroadcastOptions = Pick<\n  Cache.BatchOptions<InMemoryCache>,\n  \"optimistic\" | \"onWatchUpdated\"\n>;\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: EntityStore;\n  private optimisticData: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private addTypenameTransform = new DocumentTransform(addTypenameToDocument);\n\n  private maybeBroadcastWatch: OptimisticWrapperFunction<\n    [Cache.WatchOptions, BroadcastOptions?],\n    any,\n    [Cache.WatchOptions]\n  >;\n\n  // Override the default value, since InMemoryCache result objects are frozen\n  // in development and expected to remain logically immutable in production.\n  public readonly assumeImmutableResults = true;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = normalizeConfig(config);\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    this.init();\n  }\n\n  private init() {\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    const rootStore = (this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    }));\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of EntityStore Layer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = rootStore.stump;\n\n    this.resetResultCache();\n  }\n\n  private resetResultCache(resetResultIdentities?: boolean) {\n    const previousReader = this.storeReader;\n    const { fragments } = this.config;\n\n    // The StoreWriter is mostly stateless and so doesn't really need to be\n    // reset, but it does need to have its writer.storeReader reference updated,\n    // so it's simpler to update this.storeWriter as well.\n    this.storeWriter = new StoreWriter(\n      this,\n      (this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n        resultCacheMaxSize: this.config.resultCacheMaxSize,\n        canonizeResults: shouldCanonizeResults(this.config),\n        canon: resetResultIdentities\n          ? void 0\n          : previousReader && previousReader.canon,\n        fragments,\n      })),\n      fragments\n    );\n\n    this.maybeBroadcastWatch = wrap(\n      (c: Cache.WatchOptions, options?: BroadcastOptions) => {\n        return this.broadcastWatch(c, options);\n      },\n      {\n        max: this.config.resultCacheMaxSize,\n        makeCacheKey: (c: Cache.WatchOptions) => {\n          // Return a cache key (thus enabling result caching) only if we're\n          // currently using a data store that can track cache dependencies.\n          const store = c.optimistic ? this.optimisticData : this.data;\n          if (supportsResultCaching(store)) {\n            const { optimistic, id, variables } = c;\n            return store.makeCacheKey(\n              c.query,\n              // Different watches can have the same query, optimistic\n              // status, rootId, and variables, but if their callbacks are\n              // different, the (identical) result needs to be delivered to\n              // each distinct callback. The easiest way to achieve that\n              // separation is to include c.callback in the cache key for\n              // maybeBroadcastWatch calls. See issue #5733.\n              c.callback,\n              canonicalStringify({ optimistic, id, variables })\n            );\n          }\n        },\n      }\n    );\n\n    // Since we have thrown away all the cached functions that depend on the\n    // CacheGroup dependencies maintained by EntityStore, we should also reset\n    // all CacheGroup dependency information.\n    new Set([this.data.group, this.optimisticData.group]).forEach((group) =>\n      group.resetCaching()\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    this.init();\n    // Since calling this.init() discards/replaces the entire StoreReader, along\n    // with the result caches it maintains, this.data.replace(data) won't have\n    // to bother deleting the old data.\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return (\n        this.storeReader.diffQueryAgainstStore<T>({\n          ...options,\n          store: options.optimistic ? this.optimisticData : this.data,\n          config: this.config,\n          returnPartialData,\n        }).result || null\n      );\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not need to\n        // worry about catching \"normal\" exceptions resulting from incomplete\n        // cache data. Unexpected errors will be re-thrown. If you need more\n        // information about which fields were missing, use cache.diff instead,\n        // and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore(this.data, options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify<Entity extends Record<string, any> = Record<string, any>>(\n    options: Cache.ModifyOptions<Entity>\n  ): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store = options.optimistic // Defaults to false.\n      ? this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<TData, TVariables extends OperationVariables = any>(\n    options: Cache.DiffOptions<TData, TVariables>\n  ): Cache.DiffResult<TData> {\n    return this.storeReader.diffQueryAgainstStore({\n      ...options,\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      config: this.config,\n    });\n  }\n\n  public watch<TData = any, TVariables = any>(\n    watch: Cache.WatchOptions<TData, TVariables>\n  ): () => void {\n    if (!this.watches.size) {\n      // In case we previously called forgetCache(this) because\n      // this.watches became empty (see below), reattach this cache to any\n      // reactive variables on which it previously depended. It might seem\n      // paradoxical that we're able to recall something we supposedly\n      // forgot, but the point of calling forgetCache(this) is to silence\n      // useless broadcasts while this.watches is empty, and to allow the\n      // cache to be garbage collected. If, however, we manage to call\n      // recallCache(this) here, this cache object must not have been\n      // garbage collected yet, and should resume receiving updates from\n      // reactive variables, now that it has a watcher to notify.\n      recallCache(this);\n    }\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  public gc(options?: {\n    // If true, also free non-essential result cache memory by bulk-releasing\n    // this.{store{Reader,Writer},maybeBroadcastWatch}. Defaults to false.\n    resetResultCache?: boolean;\n    // If resetResultCache is true, this.storeReader.canon will be preserved by\n    // default, but can also be discarded by passing resetResultIdentities:true.\n    // Defaults to false.\n    resetResultIdentities?: boolean;\n  }) {\n    canonicalStringify.reset();\n    const ids = this.optimisticData.gc();\n    if (options && !this.txCount) {\n      if (options.resetResultCache) {\n        this.resetResultCache(options.resetResultIdentities);\n      } else if (options.resetResultIdentities) {\n        this.storeReader.resetCanon();\n      }\n    }\n    return ids;\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    if (isReference(object)) return object.__ref;\n    try {\n      return this.policies.identify(object)[0];\n    } catch (e) {\n      invariant.warn(e);\n    }\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      // Pass this.data as a limit on the depth of the eviction, so evictions\n      // during optimistic updates (when this.data is temporarily set equal to\n      // this.optimisticData) do not escape their optimistic Layer.\n      return this.optimisticData.evict(options, this.data);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(options?: Cache.ResetOptions): Promise<void> {\n    this.init();\n\n    canonicalStringify.reset();\n\n    if (options && options.discardWatches) {\n      // Similar to what happens in the unsubscribe function returned by\n      // cache.watch, applied to all current watches.\n      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));\n      this.watches.clear();\n      forgetCache(this);\n    } else {\n      // Calling this.init() above unblocks all maybeBroadcastWatch caching, so\n      // this.broadcastWatches() triggers a broadcast to every current watcher\n      // (letting them know their data is now missing). This default behavior is\n      // convenient because it means the watches do not have to be manually\n      // reestablished after resetting the cache. To prevent this broadcast and\n      // cancel all watches, pass true for options.discardWatches.\n      this.broadcastWatches();\n    }\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public batch<TUpdateResult>(\n    options: Cache.BatchOptions<InMemoryCache, TUpdateResult>\n  ): TUpdateResult {\n    const {\n      update,\n      optimistic = true,\n      removeOptimistic,\n      onWatchUpdated,\n    } = options;\n\n    let updateResult: TUpdateResult;\n    const perform = (layer?: EntityStore): TUpdateResult => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        return (updateResult = update(this));\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    const alreadyDirty = new Set<Cache.WatchOptions>();\n\n    if (onWatchUpdated && !this.txCount) {\n      // If an options.onWatchUpdated callback is provided, we want to call it\n      // with only the Cache.WatchOptions objects affected by options.update,\n      // but there might be dirty watchers already waiting to be broadcast that\n      // have nothing to do with the update. To prevent including those watchers\n      // in the post-update broadcast, we perform this initial broadcast to\n      // collect the dirty watchers, so we can re-dirty them later, after the\n      // post-update broadcast, allowing them to receive their pending\n      // broadcasts the next time broadcastWatches is called, just as they would\n      // if we never called cache.batch.\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch) {\n          alreadyDirty.add(watch);\n          return false;\n        },\n      });\n    }\n\n    if (typeof optimistic === \"string\") {\n      // Note that there can be multiple layers with the same optimistic ID.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n    } else if (optimistic === false) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the update. Note that\n      // this.data could be a Layer if we are currently executing an optimistic\n      // update function, but otherwise will always be an EntityStore.Root\n      // instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and run\n      // the update with broadcast batching.\n      perform();\n    }\n\n    if (typeof removeOptimistic === \"string\") {\n      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n    }\n\n    // Note: if this.txCount > 0, then alreadyDirty.size === 0, so this code\n    // takes the else branch and calls this.broadcastWatches(options), which\n    // does nothing when this.txCount > 0.\n    if (onWatchUpdated && alreadyDirty.size) {\n      this.broadcastWatches({\n        ...options,\n        onWatchUpdated(watch, diff) {\n          const result = onWatchUpdated.call(this, watch, diff);\n          if (result !== false) {\n            // Since onWatchUpdated did not return false, this diff is\n            // about to be broadcast to watch.callback, so we don't need\n            // to re-dirty it with the other alreadyDirty watches below.\n            alreadyDirty.delete(watch);\n          }\n          return result;\n        },\n      });\n      // Silently re-dirty any watches that were already dirty before the update\n      // was performed, and were not broadcast just now.\n      if (alreadyDirty.size) {\n        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));\n      }\n    } else {\n      // If alreadyDirty is empty or we don't have an onWatchUpdated\n      // function, we don't need to go to the trouble of wrapping\n      // options.onWatchUpdated.\n      this.broadcastWatches(options);\n    }\n\n    return updateResult!;\n  }\n\n  public performTransaction(\n    update: (cache: InMemoryCache) => any,\n    optimisticId?: string | null\n  ) {\n    return this.batch({\n      update,\n      optimistic: optimisticId || optimisticId !== null,\n    });\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    return this.addTypenameToDocument(this.addFragmentsToDocument(document));\n  }\n\n  protected broadcastWatches(options?: BroadcastOptions) {\n    if (!this.txCount) {\n      this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));\n    }\n  }\n\n  private addFragmentsToDocument(document: DocumentNode) {\n    const { fragments } = this.config;\n    return fragments ? fragments.transform(document) : document;\n  }\n\n  private addTypenameToDocument(document: DocumentNode) {\n    if (this.addTypename) {\n      return this.addTypenameTransform.transformDocument(document);\n    }\n    return document;\n  }\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(c: Cache.WatchOptions, options?: BroadcastOptions) {\n    const { lastDiff } = c;\n\n    // Both WatchOptions and DiffOptions extend ReadOptions, and DiffOptions\n    // currently requires no additional properties, so we can use c (a\n    // WatchOptions object) as DiffOptions, without having to allocate a new\n    // object, and without having to enumerate the relevant properties (query,\n    // variables, etc.) explicitly. There will be some additional properties\n    // (lastDiff, callback, etc.), but cache.diff ignores them.\n    const diff = this.diff<any>(c);\n\n    if (options) {\n      if (c.optimistic && typeof options.optimistic === \"string\") {\n        diff.fromOptimisticTransaction = true;\n      }\n\n      if (\n        options.onWatchUpdated &&\n        options.onWatchUpdated.call(this, c, diff, lastDiff) === false\n      ) {\n        // Returning false from the onWatchUpdated callback will prevent\n        // calling c.callback(diff) for this watcher.\n        return;\n      }\n    }\n\n    if (!lastDiff || !equal(lastDiff.result, diff.result)) {\n      c.callback((c.lastDiff = diff), lastDiff);\n    }\n  }\n}\n", "import type {\n  DocumentNode,\n  ASTNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n} from \"graphql\";\nimport { visit } from \"graphql\";\n\nimport { wrap } from \"optimism\";\n\nimport type { FragmentMap } from \"../../utilities/index.js\";\nimport { getFragmentDefinitions } from \"../../utilities/index.js\";\n\nexport interface FragmentRegistryAPI {\n  register(...fragments: DocumentNode[]): this;\n  lookup(fragmentName: string): FragmentDefinitionNode | null;\n  transform<D extends DocumentNode>(document: D): D;\n}\n\n// As long as createFragmentRegistry is not imported or used, the\n// FragmentRegistry example implementation provided below should not be bundled\n// (by tree-shaking bundlers like Rollup), because the implementation of\n// InMemoryCache refers only to the TypeScript interface FragmentRegistryAPI,\n// never the concrete implementation FragmentRegistry (which is deliberately not\n// exported from this module).\nexport function createFragmentRegistry(\n  ...fragments: DocumentNode[]\n): FragmentRegistryAPI {\n  return new FragmentRegistry(...fragments);\n}\n\nconst { forEach: arrayLikeForEach } = Array.prototype;\n\nclass FragmentRegistry implements FragmentRegistryAPI {\n  private registry: FragmentMap = Object.create(null);\n\n  // Call static method FragmentRegistry.from(...) instead of invoking the\n  // FragmentRegistry constructor directly. This reserves the constructor for\n  // future configuration of the FragmentRegistry.\n  constructor(...fragments: DocumentNode[]) {\n    this.resetCaches();\n    if (fragments.length) {\n      this.register.apply(this, fragments);\n    }\n  }\n\n  public register(): this {\n    const definitions = new Map<string, FragmentDefinitionNode>();\n    arrayLikeForEach.call(arguments, (doc: DocumentNode) => {\n      getFragmentDefinitions(doc).forEach((node) => {\n        definitions.set(node.name.value, node);\n      });\n    });\n\n    definitions.forEach((node, name) => {\n      if (node !== this.registry[name]) {\n        this.registry[name] = node;\n        this.invalidate(name);\n      }\n    });\n\n    return this;\n  }\n\n  // Overridden in the resetCaches method below.\n  private invalidate(name: string) {}\n\n  public resetCaches() {\n    this.invalidate = (this.lookup = this.cacheUnaryMethod(\"lookup\")).dirty; // This dirty function is bound to the wrapped lookup method.\n    this.transform = this.cacheUnaryMethod(\"transform\");\n    this.findFragmentSpreads = this.cacheUnaryMethod(\"findFragmentSpreads\");\n  }\n\n  private cacheUnaryMethod<\n    TName extends keyof Pick<\n      FragmentRegistry,\n      \"lookup\" | \"transform\" | \"findFragmentSpreads\"\n    >,\n  >(name: TName) {\n    const registry = this;\n    const originalMethod = FragmentRegistry.prototype[name];\n    return wrap(\n      function () {\n        return originalMethod.apply(registry, arguments);\n      },\n      {\n        makeCacheKey: (arg) => arg,\n      }\n    );\n  }\n\n  public lookup(fragmentName: string): FragmentDefinitionNode | null {\n    return this.registry[fragmentName] || null;\n  }\n\n  public transform<D extends DocumentNode>(document: D): D {\n    const defined = new Map<string, FragmentDefinitionNode>();\n    getFragmentDefinitions(document).forEach((def) => {\n      defined.set(def.name.value, def);\n    });\n\n    const unbound = new Set<string>();\n    const enqueue = (spreadName: string) => {\n      if (!defined.has(spreadName)) {\n        unbound.add(spreadName);\n      }\n    };\n\n    const enqueueChildSpreads = (node: ASTNode) =>\n      Object.keys(this.findFragmentSpreads(node)).forEach(enqueue);\n\n    enqueueChildSpreads(document);\n\n    const missing: string[] = [];\n    const map: FragmentMap = Object.create(null);\n\n    // This Set forEach loop can be extended during iteration by adding\n    // additional strings to the unbound set.\n    unbound.forEach((fragmentName) => {\n      const knownFragmentDef = defined.get(fragmentName);\n      if (knownFragmentDef) {\n        enqueueChildSpreads((map[fragmentName] = knownFragmentDef));\n      } else {\n        missing.push(fragmentName);\n        const def = this.lookup(fragmentName);\n        if (def) {\n          enqueueChildSpreads((map[fragmentName] = def));\n        }\n      }\n    });\n\n    if (missing.length) {\n      const defsToAppend: FragmentDefinitionNode[] = [];\n      missing.forEach((name) => {\n        const def = map[name];\n        if (def) {\n          defsToAppend.push(def);\n        }\n      });\n\n      if (defsToAppend.length) {\n        document = {\n          ...document,\n          definitions: document.definitions.concat(defsToAppend),\n        };\n      }\n    }\n\n    return document;\n  }\n\n  public findFragmentSpreads(root: ASTNode): FragmentSpreadMap {\n    const spreads: FragmentSpreadMap = Object.create(null);\n\n    visit(root, {\n      FragmentSpread(node) {\n        spreads[node.name.value] = node;\n      },\n    });\n\n    return spreads;\n  }\n}\n\ninterface FragmentSpreadMap {\n  [fragmentSpreadName: string]: FragmentSpreadNode;\n}\n", "/**\n * The current status of a querys execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus?: NetworkStatus\n): boolean {\n  return networkStatus ? networkStatus < 7 : false;\n}\n\n/**\n * Returns true if the network request is in ready or error state according to a given network\n * status.\n */\nexport function isNetworkRequestSettled(\n  networkStatus?: NetworkStatus\n): boolean {\n  return networkStatus === 7 || networkStatus === 8;\n}\n", "import equal from \"@wry/equality\";\n\nimport type {\n  DirectiveNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionNode,\n  SelectionSetNode,\n} from \"graphql\";\n\nimport type { ApolloQueryResult, OperationVariables } from \"./types.js\";\n\nimport type { FragmentMap } from \"../utilities/index.js\";\nimport {\n  createFragmentMap,\n  getFragmentDefinitions,\n  getFragmentFromSelection,\n  getMainDefinition,\n  isField,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\n\n// Returns true if aResult and bResult are deeply equal according to the fields\n// selected by the given query, ignoring any fields marked as @nonreactive.\nexport function equalByQuery(\n  query: DocumentNode,\n  { data: aData, ...aRest }: Partial<ApolloQueryResult<unknown>>,\n  { data: bData, ...bRest }: Partial<ApolloQueryResult<unknown>>,\n  variables?: OperationVariables\n): boolean {\n  return (\n    equal(aRest, bRest) &&\n    equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {\n      fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n      variables,\n    })\n  );\n}\n\n// Encapsulates the information used by equalBySelectionSet that does not change\n// during the recursion.\ninterface CompareContext<TVariables> {\n  fragmentMap: FragmentMap;\n  variables: TVariables | undefined;\n}\n\nfunction equalBySelectionSet(\n  selectionSet: SelectionSetNode,\n  aResult: any,\n  bResult: any,\n  context: CompareContext<OperationVariables>\n): boolean {\n  if (aResult === bResult) {\n    return true;\n  }\n\n  const seenSelections = new Set<SelectionNode>();\n\n  // Returning true from this Array.prototype.every callback function skips the\n  // current field/subtree. Returning false aborts the entire traversal\n  // immediately, causing equalBySelectionSet to return false.\n  return selectionSet.selections.every((selection) => {\n    // Avoid re-processing the same selection at the same level of recursion, in\n    // case the same field gets included via multiple indirect fragment spreads.\n    if (seenSelections.has(selection)) return true;\n    seenSelections.add(selection);\n\n    // Ignore @skip(if: true) and @include(if: false) fields.\n    if (!shouldInclude(selection, context.variables)) return true;\n\n    // If the field or (named) fragment spread has a @nonreactive directive on\n    // it, we don't care if it's different, so we pretend it's the same.\n    if (selectionHasNonreactiveDirective(selection)) return true;\n\n    if (isField(selection)) {\n      const resultKey = resultKeyNameFromField(selection);\n      const aResultChild = aResult && aResult[resultKey];\n      const bResultChild = bResult && bResult[resultKey];\n      const childSelectionSet = selection.selectionSet;\n\n      if (!childSelectionSet) {\n        // These are scalar values, so we can compare them with deep equal\n        // without redoing the main recursive work.\n        return equal(aResultChild, bResultChild);\n      }\n\n      const aChildIsArray = Array.isArray(aResultChild);\n      const bChildIsArray = Array.isArray(bResultChild);\n      if (aChildIsArray !== bChildIsArray) return false;\n      if (aChildIsArray && bChildIsArray) {\n        const length = aResultChild.length;\n        if (bResultChild.length !== length) {\n          return false;\n        }\n        for (let i = 0; i < length; ++i) {\n          if (\n            !equalBySelectionSet(\n              childSelectionSet,\n              aResultChild[i],\n              bResultChild[i],\n              context\n            )\n          ) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      return equalBySelectionSet(\n        childSelectionSet,\n        aResultChild,\n        bResultChild,\n        context\n      );\n    } else {\n      const fragment = getFragmentFromSelection(selection, context.fragmentMap);\n      if (fragment) {\n        // The fragment might === selection if it's an inline fragment, but\n        // could be !== if it's a named fragment ...spread.\n        if (selectionHasNonreactiveDirective(fragment)) return true;\n\n        return equalBySelectionSet(\n          fragment.selectionSet,\n          // Notice that we reuse the same aResult and bResult values here,\n          // since the fragment ...spread does not specify a field name, but\n          // consists of multiple fields (within the fragment's selection set)\n          // that should be applied to the current result value(s).\n          aResult,\n          bResult,\n          context\n        );\n      }\n    }\n  });\n}\n\nfunction selectionHasNonreactiveDirective(\n  selection:\n    | FieldNode\n    | InlineFragmentNode\n    | FragmentSpreadNode\n    | FragmentDefinitionNode\n): boolean {\n  return (\n    !!selection.directives && selection.directives.some(directiveIsNonreactive)\n  );\n}\n\nfunction directiveIsNonreactive(dir: DirectiveNode): boolean {\n  return dir.name.value === \"nonreactive\";\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\nimport type { DocumentNode } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  Concast,\n  Observer,\n  ObservableSubscription,\n} from \"../utilities/index.js\";\nimport {\n  cloneDeep,\n  compact,\n  getOperationDefinition,\n  Observable,\n  iterateObserversSafely,\n  fixObservableSubclass,\n  getQueryDefinition,\n} from \"../utilities/index.js\";\nimport type { ApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"./types.js\";\nimport type {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  NextFetchPolicyContext,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport type { QueryInfo } from \"./QueryInfo.js\";\nimport type { MissingFieldError } from \"../cache/index.js\";\nimport type { MissingTree } from \"../cache/core/types/common.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\n\nconst { assign, hasOwnProperty } = Object;\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables,\n> {\n  updateQuery?: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    }\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\ninterface Last<TData, TVariables> {\n  result: ApolloQueryResult<TData>;\n  variables?: TVariables;\n  error?: ApolloError;\n}\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n> extends Observable<ApolloQueryResult<TData>> {\n  public readonly options: WatchQueryOptions<TVariables, TData>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n\n  // The `query` computed property will always reflect the document transformed\n  // by the last run query. `this.options.query` will always reflect the raw\n  // untransformed query to ensure document transforms with runtime conditionals\n  // are run on the original document.\n  public get query(): TypedDocumentNode<TData, TVariables> {\n    return this.lastQuery || this.options.query;\n  }\n\n  // Computed shorthand for this.options.variables, preserved for\n  // backwards compatibility.\n  public get variables(): TVariables | undefined {\n    return this.options.variables;\n  }\n\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<ObservableSubscription>();\n\n  private waitForOwnResult: boolean;\n  private last?: Last<TData, TVariables>;\n  private lastQuery?: DocumentNode;\n\n  private queryInfo: QueryInfo;\n\n  // When this.concast is defined, this.observer is the Observer currently\n  // subscribed to that Concast.\n  private concast?: Concast<ApolloQueryResult<TData>>;\n  private observer?: Observer<ApolloQueryResult<TData>>;\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  constructor({\n    queryManager,\n    queryInfo,\n    options,\n  }: {\n    queryManager: QueryManager<any>;\n    queryInfo: QueryInfo;\n    options: WatchQueryOptions<TVariables, TData>;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) => {\n      // Zen Observable has its own error function, so in order to log correctly\n      // we need to provide a custom error callback.\n      try {\n        var subObserver = (observer as any)._subscription._observer;\n        if (subObserver && !subObserver.error) {\n          subObserver.error = defaultSubscriptionObserverErrorCallback;\n        }\n      } catch {}\n\n      const first = !this.observers.size;\n      this.observers.add(observer);\n\n      // Deliver most recent error or result.\n      const last = this.last;\n      if (last && last.error) {\n        observer.error && observer.error(last.error);\n      } else if (last && last.result) {\n        observer.next && observer.next(last.result);\n      }\n\n      // Initiate observation of this query if it hasn't been reported to\n      // the QueryManager yet.\n      if (first) {\n        // Blindly catching here prevents unhandled promise rejections,\n        // and is safe because the ObservableQuery handles this error with\n        // this.observer.error, so we're not just swallowing the error by\n        // ignoring it here.\n        this.reobserve().catch(() => {});\n      }\n\n      return () => {\n        if (this.observers.delete(observer) && !this.observers.size) {\n          this.tearDownQuery();\n        }\n      };\n    });\n\n    // related classes\n    this.queryInfo = queryInfo;\n    this.queryManager = queryManager;\n\n    // active state\n    this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n    this.isTornDown = false;\n\n    const {\n      watchQuery: { fetchPolicy: defaultFetchPolicy = \"cache-first\" } = {},\n    } = queryManager.defaultOptions;\n\n    const {\n      fetchPolicy = defaultFetchPolicy,\n      // Make sure we don't store \"standby\" as the initialFetchPolicy.\n      initialFetchPolicy = fetchPolicy === \"standby\"\n        ? defaultFetchPolicy\n        : fetchPolicy,\n    } = options;\n\n    this.options = {\n      ...options,\n\n      // Remember the initial options.fetchPolicy so we can revert back to this\n      // policy when variables change. This information can also be specified\n      // (or overridden) by providing options.initialFetchPolicy explicitly.\n      initialFetchPolicy,\n\n      // This ensures this.options.fetchPolicy always has a string value, in\n      // case options.fetchPolicy was not provided.\n      fetchPolicy,\n    };\n\n    this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n\n    const opDef = getOperationDefinition(this.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      // TODO: this code doesnt actually make sense insofar as the observer\n      // will never exist in this.observers due how zen-observable wraps observables.\n      // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  public getCurrentResult(saveAsLastResult = true): ApolloQueryResult<TData> {\n    // Use the last result as long as the variables match this.variables.\n    const lastResult = this.getLastResult(true);\n\n    const networkStatus =\n      this.queryInfo.networkStatus ||\n      (lastResult && lastResult.networkStatus) ||\n      NetworkStatus.ready;\n\n    const result = {\n      ...lastResult,\n      loading: isNetworkRequestInFlight(networkStatus),\n      networkStatus,\n    } as ApolloQueryResult<TData>;\n\n    const { fetchPolicy = \"cache-first\" } = this.options;\n    if (\n      // These fetch policies should never deliver data from the cache, unless\n      // redelivering a previously delivered result.\n      skipCacheDataFor(fetchPolicy) ||\n      // If this.options.query has @client(always: true) fields, we cannot\n      // trust diff.result, since it was read from the cache without running\n      // local resolvers (and it's too late to run resolvers now, since we must\n      // return a result synchronously).\n      this.queryManager.getDocumentInfo(this.query).hasForcedResolvers\n    ) {\n      // Fall through.\n    } else if (this.waitForOwnResult) {\n      // This would usually be a part of `QueryInfo.getDiff()`.\n      // which we skip in the waitForOwnResult case since we are not\n      // interested in the diff.\n      this.queryInfo[\"updateWatch\"]();\n    } else {\n      const diff = this.queryInfo.getDiff();\n\n      if (diff.complete || this.options.returnPartialData) {\n        result.data = diff.result;\n      }\n\n      if (equal(result.data, {})) {\n        result.data = void 0 as any;\n      }\n\n      if (diff.complete) {\n        // Similar to setting result.partial to false, but taking advantage of the\n        // falsiness of missing fields.\n        delete result.partial;\n\n        // If the diff is complete, and we're using a FetchPolicy that\n        // terminates after a complete cache read, we can assume the next result\n        // we receive will have NetworkStatus.ready and !loading.\n        if (\n          diff.complete &&\n          result.networkStatus === NetworkStatus.loading &&\n          (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")\n        ) {\n          result.networkStatus = NetworkStatus.ready;\n          result.loading = false;\n        }\n      } else {\n        result.partial = true;\n      }\n\n      if (\n        __DEV__ &&\n        !diff.complete &&\n        !this.options.partialRefetch &&\n        !result.loading &&\n        !result.data &&\n        !result.error\n      ) {\n        logMissingFieldErrors(diff.missing);\n      }\n    }\n\n    if (saveAsLastResult) {\n      this.updateLastResult(result);\n    }\n\n    return result;\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(\n    newResult: ApolloQueryResult<TData>,\n    variables?: TVariables\n  ) {\n    if (!this.last) {\n      return true;\n    }\n\n    const resultIsDifferent = this.queryManager.getDocumentInfo(this.query)\n      .hasNonreactiveDirective\n      ? !equalByQuery(this.query, this.last.result, newResult, this.variables)\n      : !equal(this.last.result, newResult);\n\n    return (\n      resultIsDifferent || (variables && !equal(this.last.variables, variables))\n    );\n  }\n\n  private getLast<K extends keyof Last<TData, TVariables>>(\n    key: K,\n    variablesMustMatch?: boolean\n  ) {\n    const last = this.last;\n    if (\n      last &&\n      last[key] &&\n      (!variablesMustMatch || equal(last.variables, this.variables))\n    ) {\n      return last[key];\n    }\n  }\n\n  public getLastResult(\n    variablesMustMatch?: boolean\n  ): ApolloQueryResult<TData> | undefined {\n    return this.getLast(\"result\", variablesMustMatch);\n  }\n\n  public getLastError(variablesMustMatch?: boolean): ApolloError | undefined {\n    return this.getLast(\"error\", variablesMustMatch);\n  }\n\n  public resetLastResults(): void {\n    delete this.last;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    this.queryManager.resetErrors(this.queryId);\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(\n    variables?: Partial<TVariables>\n  ): Promise<ApolloQueryResult<TData>> {\n    const reobserveOptions: Partial<WatchQueryOptions<TVariables, TData>> = {\n      // Always disable polling for refetches.\n      pollInterval: 0,\n    };\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    const { fetchPolicy } = this.options;\n    if (fetchPolicy === \"cache-and-network\") {\n      reobserveOptions.fetchPolicy = fetchPolicy;\n    } else if (fetchPolicy === \"no-cache\") {\n      reobserveOptions.fetchPolicy = \"no-cache\";\n    } else {\n      reobserveOptions.fetchPolicy = \"network-only\";\n    }\n\n    if (__DEV__ && variables && hasOwnProperty.call(variables, \"variables\")) {\n      const queryDef = getQueryDefinition(this.query);\n      const vars = queryDef.variableDefinitions;\n      if (!vars || !vars.some((v) => v.variable.name.value === \"variables\")) {\n        invariant.warn(\n          `Called refetch(%o) for query %o, which does not declare a $variables variable.\nDid you mean to call refetch(variables) instead of refetch({ variables })?`,\n          variables,\n          queryDef.name?.value || queryDef\n        );\n      }\n    }\n\n    if (variables && !equal(this.options.variables, variables)) {\n      // Update the existing options with new variables\n      reobserveOptions.variables = this.options.variables = {\n        ...this.options.variables,\n        ...variables,\n      } as TVariables;\n    }\n\n    this.queryInfo.resetLastWrite();\n    return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n  }\n\n  public fetchMore<\n    TFetchData = TData,\n    TFetchVars extends OperationVariables = TVariables,\n  >(\n    fetchMoreOptions: FetchMoreQueryOptions<TFetchVars, TFetchData> & {\n      updateQuery?: (\n        previousQueryResult: TData,\n        options: {\n          fetchMoreResult: TFetchData;\n          variables: TFetchVars;\n        }\n      ) => TData;\n    }\n  ): Promise<ApolloQueryResult<TFetchData>> {\n    const combinedOptions = {\n      ...(fetchMoreOptions.query\n        ? fetchMoreOptions\n        : {\n            ...this.options,\n            query: this.options.query,\n            ...fetchMoreOptions,\n            variables: {\n              ...this.options.variables,\n              ...fetchMoreOptions.variables,\n            },\n          }),\n      // The fetchMore request goes immediately to the network and does\n      // not automatically write its result to the cache (hence no-cache\n      // instead of network-only), because we allow the caller of\n      // fetchMore to provide an updateQuery callback that determines how\n      // the data gets written to the cache.\n      fetchPolicy: \"no-cache\",\n    } as WatchQueryOptions<TFetchVars, TFetchData>;\n\n    combinedOptions.query = this.transformDocument(combinedOptions.query);\n\n    const qid = this.queryManager.generateQueryId();\n\n    // If a temporary query is passed to `fetchMore`, we don't want to store\n    // it as the last query result since it may be an optimized query for\n    // pagination. We will however run the transforms on the original document\n    // as well as the document passed in `fetchMoreOptions` to ensure the cache\n    // uses the most up-to-date document which may rely on runtime conditionals.\n    this.lastQuery = fetchMoreOptions.query\n      ? this.transformDocument(this.options.query)\n      : combinedOptions.query;\n\n    // Simulate a loading result for the original query with\n    // result.networkStatus === NetworkStatus.fetchMore.\n    const { queryInfo } = this;\n    const originalNetworkStatus = queryInfo.networkStatus;\n    queryInfo.networkStatus = NetworkStatus.fetchMore;\n    if (combinedOptions.notifyOnNetworkStatusChange) {\n      this.observe();\n    }\n\n    const updatedQuerySet = new Set<DocumentNode>();\n\n    return this.queryManager\n      .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\n      .then((fetchMoreResult) => {\n        this.queryManager.removeQuery(qid);\n\n        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n          queryInfo.networkStatus = originalNetworkStatus;\n        }\n\n        // Performing this cache update inside a cache.batch transaction ensures\n        // any affected cache.watch watchers are notified at most once about any\n        // updates. Most watchers will be using the QueryInfo class, which\n        // responds to notifications by calling reobserveCacheFirst to deliver\n        // fetchMore cache results back to this ObservableQuery.\n        this.queryManager.cache.batch({\n          update: (cache) => {\n            const { updateQuery } = fetchMoreOptions;\n            if (updateQuery) {\n              cache.updateQuery(\n                {\n                  query: this.query,\n                  variables: this.variables,\n                  returnPartialData: true,\n                  optimistic: false,\n                },\n                (previous) =>\n                  updateQuery(previous!, {\n                    fetchMoreResult: fetchMoreResult.data,\n                    variables: combinedOptions.variables as TFetchVars,\n                  })\n              );\n            } else {\n              // If we're using a field policy instead of updateQuery, the only\n              // thing we need to do is write the new data to the cache using\n              // combinedOptions.variables (instead of this.variables, which is\n              // what this.updateQuery uses, because it works by abusing the\n              // original field value, keyed by the original variables).\n              cache.writeQuery({\n                query: combinedOptions.query,\n                variables: combinedOptions.variables,\n                data: fetchMoreResult.data,\n              });\n            }\n          },\n\n          onWatchUpdated: (watch) => {\n            // Record the DocumentNode associated with any watched query whose\n            // data were updated by the cache writes above.\n            updatedQuerySet.add(watch.query);\n          },\n        });\n\n        return fetchMoreResult;\n      })\n      .finally(() => {\n        // In case the cache writes above did not generate a broadcast\n        // notification (which would have been intercepted by onWatchUpdated),\n        // likely because the written data were the same as what was already in\n        // the cache, we still want fetchMore to deliver its final loading:false\n        // result with the unchanged data.\n        if (!updatedQuerySet.has(this.query)) {\n          reobserveCacheFirst(this);\n        }\n      });\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables extends OperationVariables = TVariables,\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                })\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error(\"Unhandled GraphQL subscription error\", err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  public setOptions(\n    newOptions: Partial<WatchQueryOptions<TVariables, TData>>\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.reobserve(newOptions);\n  }\n\n  public silentSetOptions(\n    newOptions: Partial<WatchQueryOptions<TVariables, TData>>\n  ) {\n    const mergedOptions = compact(this.options, newOptions || {});\n    assign(this.options, mergedOptions);\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. Most users should prefer `refetch` instead of\n   * `setVariables` in order to to be properly notified of results even when\n   * they come from the cache.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public setVariables(\n    variables: TVariables\n  ): Promise<ApolloQueryResult<TData> | void> {\n    if (equal(this.variables, variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size ? this.result() : Promise.resolve();\n    }\n\n    this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    return this.reobserve(\n      {\n        // Reset options.fetchPolicy to its original value.\n        fetchPolicy: this.options.initialFetchPolicy,\n        variables,\n      },\n      NetworkStatus.setVariables\n    );\n  }\n\n  public updateQuery<TVars extends OperationVariables = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: Pick<WatchQueryOptions<TVars, TData>, \"variables\">\n    ) => TData\n  ): void {\n    const { queryManager } = this;\n    const { result } = queryManager.cache.diff<TData>({\n      query: this.options.query,\n      variables: this.variables,\n      returnPartialData: true,\n      optimistic: false,\n    });\n\n    const newResult = mapFn(result!, {\n      variables: (this as any).variables,\n    });\n\n    if (newResult) {\n      queryManager.cache.writeQuery({\n        query: this.options.query,\n        data: newResult,\n        variables: this.variables,\n      });\n\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public startPolling(pollInterval: number) {\n    this.options.pollInterval = pollInterval;\n    this.updatePolling();\n  }\n\n  public stopPolling() {\n    this.options.pollInterval = 0;\n    this.updatePolling();\n  }\n\n  // Update options.fetchPolicy according to options.nextFetchPolicy.\n  private applyNextFetchPolicy(\n    reason: NextFetchPolicyContext<TData, TVariables>[\"reason\"],\n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options: WatchQueryOptions<TVariables, TData>\n  ) {\n    if (options.nextFetchPolicy) {\n      const { fetchPolicy = \"cache-first\", initialFetchPolicy = fetchPolicy } =\n        options;\n\n      if (fetchPolicy === \"standby\") {\n        // Do nothing, leaving options.fetchPolicy unchanged.\n      } else if (typeof options.nextFetchPolicy === \"function\") {\n        // When someone chooses \"cache-and-network\" or \"network-only\" as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the \"cache-and-network\" or \"network-only\" policies would\n        // seem to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete. To\n        // that end, the options.nextFetchPolicy option provides an easy way to\n        // update options.fetchPolicy after the initial network request, without\n        // having to call observableQuery.setOptions.\n        options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n          reason,\n          options,\n          observable: this,\n          initialFetchPolicy,\n        });\n      } else if (reason === \"variables-changed\") {\n        options.fetchPolicy = initialFetchPolicy;\n      } else {\n        options.fetchPolicy = options.nextFetchPolicy;\n      }\n    }\n\n    return options.fetchPolicy;\n  }\n\n  private fetch(\n    options: WatchQueryOptions<TVariables, TData>,\n    newNetworkStatus?: NetworkStatus,\n    query?: DocumentNode\n  ) {\n    // TODO Make sure we update the networkStatus (and infer fetchVariables)\n    // before actually committing to the fetch.\n    this.queryManager.setObservableQuery(this);\n    return this.queryManager[\"fetchConcastWithInfo\"](\n      this.queryId,\n      options,\n      newNetworkStatus,\n      query\n    );\n  }\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    // Avoid polling in SSR mode\n    if (this.queryManager.ssrMode) {\n      return;\n    }\n\n    const {\n      pollingInfo,\n      options: { pollInterval },\n    } = this;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      \"Attempted to start a polling query without a polling interval.\"\n    );\n\n    const info = pollingInfo || (this.pollingInfo = {} as any);\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (!isNetworkRequestInFlight(this.queryInfo.networkStatus)) {\n          this.reobserve(\n            {\n              // Most fetchPolicy options don't make sense to use in a polling context, as\n              // users wouldn't want to be polling the cache directly. However, network-only and\n              // no-cache are both useful for when the user wants to control whether or not the\n              // polled results are written to the cache.\n              fetchPolicy:\n                this.options.initialFetchPolicy === \"no-cache\"\n                  ? \"no-cache\"\n                  : \"network-only\",\n            },\n            NetworkStatus.poll\n          ).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n\n  private updateLastResult(\n    newResult: ApolloQueryResult<TData>,\n    variables = this.variables\n  ) {\n    let error: ApolloError | undefined = this.getLastError();\n    // Preserve this.last.error unless the variables have changed.\n    if (error && this.last && !equal(variables, this.last.variables)) {\n      error = void 0;\n    }\n    return (this.last = {\n      result: this.queryManager.assumeImmutableResults\n        ? newResult\n        : cloneDeep(newResult),\n      variables,\n      ...(error ? { error } : null),\n    });\n  }\n\n  public reobserveAsConcast(\n    newOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n    newNetworkStatus?: NetworkStatus\n  ): Concast<ApolloQueryResult<TData>> {\n    this.isTornDown = false;\n\n    const useDisposableConcast =\n      // Refetching uses a disposable Concast to allow refetches using different\n      // options/variables, without permanently altering the options of the\n      // original ObservableQuery.\n      newNetworkStatus === NetworkStatus.refetch ||\n      // The fetchMore method does not actually call the reobserve method, but,\n      // if it did, it would definitely use a disposable Concast.\n      newNetworkStatus === NetworkStatus.fetchMore ||\n      // Polling uses a disposable Concast so the polling options (which force\n      // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n      newNetworkStatus === NetworkStatus.poll;\n\n    // Save the old variables, since Object.assign may modify them below.\n    const oldVariables = this.options.variables;\n    const oldFetchPolicy = this.options.fetchPolicy;\n\n    const mergedOptions = compact(this.options, newOptions || {});\n    const options = useDisposableConcast\n      ? // Disposable Concast fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions\n      : assign(this.options, mergedOptions);\n\n    // Don't update options.query with the transformed query to avoid\n    // overwriting this.options.query when we aren't using a disposable concast.\n    // We want to ensure we can re-run the custom document transforms the next\n    // time a request is made against the original query.\n    const query = this.transformDocument(options.query);\n\n    this.lastQuery = query;\n\n    if (!useDisposableConcast) {\n      // We can skip calling updatePolling if we're not changing this.options.\n      this.updatePolling();\n\n      // Reset options.fetchPolicy to its original value when variables change,\n      // unless a new fetchPolicy was provided by newOptions.\n      if (\n        newOptions &&\n        newOptions.variables &&\n        !equal(newOptions.variables, oldVariables) &&\n        // Don't mess with the fetchPolicy if it's currently \"standby\".\n        options.fetchPolicy !== \"standby\" &&\n        // If we're changing the fetchPolicy anyway, don't try to change it here\n        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n        options.fetchPolicy === oldFetchPolicy\n      ) {\n        this.applyNextFetchPolicy(\"variables-changed\", options);\n        if (newNetworkStatus === void 0) {\n          newNetworkStatus = NetworkStatus.setVariables;\n        }\n      }\n    }\n\n    this.waitForOwnResult &&= skipCacheDataFor(options.fetchPolicy);\n    const finishWaitingForOwnResult = () => {\n      if (this.concast === concast) {\n        this.waitForOwnResult = false;\n      }\n    };\n\n    const variables = options.variables && { ...options.variables };\n    const { concast, fromLink } = this.fetch(options, newNetworkStatus, query);\n    const observer: Observer<ApolloQueryResult<TData>> = {\n      next: (result) => {\n        finishWaitingForOwnResult();\n        this.reportResult(result, variables);\n      },\n      error: (error) => {\n        finishWaitingForOwnResult();\n        this.reportError(error, variables);\n      },\n    };\n\n    if (!useDisposableConcast && (fromLink || !this.concast)) {\n      // We use the {add,remove}Observer methods directly to avoid wrapping\n      // observer with an unnecessary SubscriptionObserver object.\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer);\n      }\n\n      this.concast = concast;\n      this.observer = observer;\n    }\n\n    concast.addObserver(observer);\n\n    return concast;\n  }\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVariables, TData>>,\n    newNetworkStatus?: NetworkStatus\n  ) {\n    return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;\n  }\n\n  public resubscribeAfterError(\n    onNext: (value: ApolloQueryResult<TData>) => void,\n    onError?: (error: any) => void,\n    onComplete?: () => void\n  ): ObservableSubscription;\n\n  public resubscribeAfterError(\n    observer: Observer<ApolloQueryResult<TData>>\n  ): ObservableSubscription;\n\n  public resubscribeAfterError(...args: [any, any?, any?]) {\n    // If `lastError` is set in the current when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore the last value afterwards so that the\n    // subscription has a chance to stay open.\n    const last = this.last;\n    this.resetLastResults();\n\n    const subscription = this.subscribe(...args);\n    this.last = last;\n\n    return subscription;\n  }\n\n  // (Re)deliver the current result to this.observers without applying fetch\n  // policies or making network requests.\n  private observe() {\n    this.reportResult(\n      // Passing false is important so that this.getCurrentResult doesn't\n      // save the fetchMore result as this.lastResult, causing it to be\n      // ignored due to the this.isDifferentFromLastResult check in\n      // this.reportResult.\n      this.getCurrentResult(false),\n      this.variables\n    );\n  }\n\n  private reportResult(\n    result: ApolloQueryResult<TData>,\n    variables: TVariables | undefined\n  ) {\n    const lastError = this.getLastError();\n    const isDifferent = this.isDifferentFromLastResult(result, variables);\n    // Update the last result even when isDifferentFromLastResult returns false,\n    // because the query may be using the @nonreactive directive, and we want to\n    // save the the latest version of any nonreactive subtrees (in case\n    // getCurrentResult is called), even though we skip broadcasting changes.\n    if (lastError || !result.partial || this.options.returnPartialData) {\n      this.updateLastResult(result, variables);\n    }\n    if (lastError || isDifferent) {\n      iterateObserversSafely(this.observers, \"next\", result);\n    }\n  }\n\n  private reportError(error: ApolloError, variables: TVariables | undefined) {\n    // Since we don't get the current result on errors, only the error, we\n    // must mirror the updates that occur in QueryStore.markQueryError here\n    const errorResult = {\n      ...this.getLastResult(),\n      error,\n      errors: error.graphQLErrors,\n      networkStatus: NetworkStatus.error,\n      loading: false,\n    } as ApolloQueryResult<TData>;\n\n    this.updateLastResult(errorResult, variables);\n\n    iterateObserversSafely(this.observers, \"error\", (this.last!.error = error));\n  }\n\n  public hasObservers() {\n    return this.observers.size > 0;\n  }\n\n  private tearDownQuery() {\n    if (this.isTornDown) return;\n    if (this.concast && this.observer) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n      delete this.observer;\n    }\n\n    this.stopPolling();\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach((sub) => sub.unsubscribe());\n    this.subscriptions.clear();\n    this.queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n    this.isTornDown = true;\n  }\n\n  private transformDocument(document: DocumentNode) {\n    return this.queryManager.transform(document);\n  }\n}\n\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nexport function reobserveCacheFirst<TData, TVars extends OperationVariables>(\n  obsQuery: ObservableQuery<TData, TVars>\n) {\n  const { fetchPolicy, nextFetchPolicy } = obsQuery.options;\n\n  if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n    return obsQuery.reobserve({\n      fetchPolicy: \"cache-first\",\n      // Use a temporary nextFetchPolicy function that replaces itself with the\n      // previous nextFetchPolicy value and returns the original fetchPolicy.\n      nextFetchPolicy(this: WatchQueryOptions<TVars, TData>) {\n        // Replace this nextFetchPolicy function in the options object with the\n        // original this.options.nextFetchPolicy value.\n        this.nextFetchPolicy = nextFetchPolicy;\n        // If the original nextFetchPolicy value was a function, give it a\n        // chance to decide what happens here.\n        if (typeof nextFetchPolicy === \"function\") {\n          return nextFetchPolicy.apply(this, arguments);\n        }\n        // Otherwise go back to the original this.options.fetchPolicy.\n        return fetchPolicy!;\n      },\n    });\n  }\n\n  return obsQuery.reobserve();\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error(\"Unhandled error\", error.message, error.stack);\n}\n\nexport function logMissingFieldErrors(\n  missing: MissingFieldError[] | MissingTree | undefined\n) {\n  if (__DEV__ && missing) {\n    invariant.debug(`Missing cache result fields: %o`, missing);\n  }\n}\n\nfunction skipCacheDataFor(\n  fetchPolicy?: WatchQueryFetchPolicy /* `undefined` would mean `\"cache-first\"` */\n) {\n  return (\n    fetchPolicy === \"network-only\" ||\n    fetchPolicy === \"no-cache\" ||\n    fetchPolicy === \"standby\"\n  );\n}\n", "import { invariant } from \"../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  DirectiveNode,\n  FragmentSpreadNode,\n  ExecutableDefinitionNode,\n} from \"graphql\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\n\nimport type { ApolloCache } from \"../cache/index.js\";\nimport type { FragmentMap, StoreObject } from \"../utilities/index.js\";\nimport {\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from \"../utilities/index.js\";\nimport type { ApolloClient } from \"./ApolloClient.js\";\nimport type { Resolvers, OperationVariables } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  }\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n  selectionsToResolve: Set<SelectionNode>;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n  private selectionsToResolveCache = new WeakMap<\n    ExecutableDefinitionNode,\n    Set<SelectionNode>\n  >();\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach((resolverGroup) => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers\n      ).then((localResult) => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives([\"client\"], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {}\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables\n      ).then((data) => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === \"client\" && node.arguments) {\n            forceResolvers = node.arguments.some(\n              (arg) =>\n                arg.name.value === \"always\" &&\n                arg.value.kind === \"BooleanValue\" &&\n                arg.value.value === true\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false\n  ) {\n    const mainDefinition = getMainDefinition(\n      document\n    ) as OperationDefinitionNode;\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n    const selectionsToResolve = this.collectSelectionsToResolve(\n      mainDefinition,\n      fragmentMap\n    );\n\n    const definitionOperation = mainDefinition.operation;\n\n    const defaultOperationType = definitionOperation\n      ? definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : \"Query\";\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      selectionsToResolve,\n      onlyRunForcedResolvers,\n    };\n    const isClientFieldDescendant = false;\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      isClientFieldDescendant,\n      rootValue,\n      execContext\n    ).then((result) => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    isClientFieldDescendant: boolean,\n    rootValue: TData,\n    execContext: ExecContext\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (\n        !isClientFieldDescendant &&\n        !execContext.selectionsToResolve.has(selection)\n      ) {\n        // Skip selections without @client directives\n        // (still processing if one of the ancestors or one of the child fields has @client directive)\n        return;\n      }\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(\n          selection,\n          isClientFieldDescendant,\n          rootValue,\n          execContext\n        ).then((fieldResult) => {\n          if (typeof fieldResult !== \"undefined\") {\n            resultsToMerge.push({\n              [resultKeyNameFromField(selection)]: fieldResult,\n            } as TData);\n          }\n        });\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named %s`, selection.name.value);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            isClientFieldDescendant,\n            rootValue,\n            execContext\n          ).then((fragmentResult) => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function () {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    rootValue: any,\n    execContext: ExecContext\n  ): Promise<any> {\n    if (!rootValue) {\n      return null;\n    }\n\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach((directive) => {\n          if (directive.name.value === \"export\" && directive.arguments) {\n            directive.arguments.forEach((arg) => {\n              if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      const isClientField =\n        field.directives?.some((d) => d.name.value === \"client\") ?? false;\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(\n          field,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          isClientFieldDescendant || isClientField,\n          result,\n          execContext\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    isClientFieldDescendant: boolean,\n    result: any[],\n    execContext: ExecContext\n  ): any {\n    return Promise.all(\n      result.map((item) => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(\n            field,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(\n            field.selectionSet,\n            isClientFieldDescendant,\n            item,\n            execContext\n          );\n        }\n      })\n    );\n  }\n\n  // Collect selection nodes on paths from document root down to all @client directives.\n  // This function takes into account transitive fragment spreads.\n  // Complexity equals to a single `visit` over the full document.\n  private collectSelectionsToResolve(\n    mainDefinition: OperationDefinitionNode,\n    fragmentMap: FragmentMap\n  ): Set<SelectionNode> {\n    const isSingleASTNode = (\n      node: ASTNode | readonly ASTNode[]\n    ): node is ASTNode => !Array.isArray(node);\n    const selectionsToResolveCache = this.selectionsToResolveCache;\n\n    function collectByDefinition(\n      definitionNode: ExecutableDefinitionNode\n    ): Set<SelectionNode> {\n      if (!selectionsToResolveCache.has(definitionNode)) {\n        const matches = new Set<SelectionNode>();\n        selectionsToResolveCache.set(definitionNode, matches);\n\n        visit(definitionNode, {\n          Directive(node: DirectiveNode, _, __, ___, ancestors) {\n            if (node.name.value === \"client\") {\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n            }\n          },\n          FragmentSpread(spread: FragmentSpreadNode, _, __, ___, ancestors) {\n            const fragment = fragmentMap[spread.name.value];\n            invariant(fragment, `No fragment named %s`, spread.name.value);\n\n            const fragmentSelections = collectByDefinition(fragment);\n            if (fragmentSelections.size > 0) {\n              // Fragment for this spread contains @client directive (either directly or transitively)\n              // Collect selection nodes on paths from the root down to fields with the @client directive\n              ancestors.forEach((node) => {\n                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                  matches.add(node);\n                }\n              });\n              matches.add(spread);\n              fragmentSelections.forEach((selection) => {\n                matches.add(selection);\n              });\n            }\n          },\n        });\n      }\n      return selectionsToResolveCache.get(definitionNode)!;\n    }\n    return collectByDefinition(mainDefinition);\n  }\n}\n", "import type { DocumentNode, GraphQLError } from \"graphql\";\nimport { equal } from \"@wry/equality\";\n\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { DeepMerger } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/index.js\";\nimport type { WatchQueryOptions, ErrorPolicy } from \"./watchQueryOptions.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\nimport { reobserveCacheFirst } from \"./ObservableQuery.js\";\nimport type { QueryListener, MethodKeys } from \"./types.js\";\nimport type { FetchResult } from \"../link/core/index.js\";\nimport {\n  isNonEmptyArray,\n  graphQLResultHasError,\n  canUseWeakMap,\n} from \"../utilities/index.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type { ApolloError } from \"../errors/index.js\";\nimport type { QueryManager } from \"./QueryManager.js\";\n\nexport type QueryStoreValue = Pick<\n  QueryInfo,\n  \"variables\" | \"networkStatus\" | \"networkError\" | \"graphQLErrors\"\n>;\n\nexport const enum CacheWriteBehavior {\n  FORBID,\n  OVERWRITE,\n  MERGE,\n}\n\nconst destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)<\n  ApolloCache<any>,\n  number\n>();\n\nfunction wrapDestructiveCacheMethod(\n  cache: ApolloCache<any>,\n  methodName: MethodKeys<ApolloCache<any>>\n) {\n  const original = cache[methodName];\n  if (typeof original === \"function\") {\n    cache[methodName] = function () {\n      destructiveMethodCounts.set(\n        cache,\n        // The %1e15 allows the count to wrap around to 0 safely every\n        // quadrillion evictions, so there's no risk of overflow. To be\n        // clear, this is more of a pedantic principle than something\n        // that matters in any conceivable practical scenario.\n        (destructiveMethodCounts.get(cache)! + 1) % 1e15\n      );\n      return original.apply(this, arguments);\n    };\n  }\n}\n\nfunction cancelNotifyTimeout(info: QueryInfo) {\n  if (info[\"notifyTimeout\"]) {\n    clearTimeout(info[\"notifyTimeout\"]);\n    info[\"notifyTimeout\"] = void 0;\n  }\n}\n\n// A QueryInfo object represents a single query managed by the\n// QueryManager, which tracks all QueryInfo objects by queryId in its\n// this.queries Map. QueryInfo objects store the latest results and errors\n// for the given query, and are responsible for reporting those results to\n// the corresponding ObservableQuery, via the QueryInfo.notify method.\n// Results are reported asynchronously whenever setDiff marks the\n// QueryInfo object as dirty, though a call to the QueryManager's\n// broadcastQueries method may trigger the notification before it happens\n// automatically. This class used to be a simple interface type without\n// any field privacy or meaningful methods, which is why it still has so\n// many public fields. The effort to lock down and simplify the QueryInfo\n// interface is ongoing, and further improvements are welcome.\nexport class QueryInfo {\n  listeners = new Set<QueryListener>();\n  document: DocumentNode | null = null;\n  lastRequestId = 1;\n  variables?: Record<string, any>;\n  networkStatus?: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  stopped = false;\n\n  private cache: ApolloCache<any>;\n\n  constructor(\n    queryManager: QueryManager<any>,\n    public readonly queryId = queryManager.generateQueryId()\n  ) {\n    const cache = (this.cache = queryManager.cache);\n\n    // Track how often cache.evict is called, since we want eviction to\n    // override the feud-stopping logic in the markResult method, by\n    // causing shouldWrite to return true. Wrapping the cache.evict method\n    // is a bit of a hack, but it saves us from having to make eviction\n    // counting an official part of the ApolloCache API.\n    if (!destructiveMethodCounts.has(cache)) {\n      destructiveMethodCounts.set(cache, 0);\n      wrapDestructiveCacheMethod(cache, \"evict\");\n      wrapDestructiveCacheMethod(cache, \"modify\");\n      wrapDestructiveCacheMethod(cache, \"reset\");\n    }\n  }\n\n  public init(query: {\n    document: DocumentNode;\n    variables: Record<string, any> | undefined;\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus?: NetworkStatus;\n    observableQuery?: ObservableQuery<any>;\n    lastRequestId?: number;\n  }): this {\n    let networkStatus = query.networkStatus || NetworkStatus.loading;\n    if (\n      this.variables &&\n      this.networkStatus !== NetworkStatus.loading &&\n      !equal(this.variables, query.variables)\n    ) {\n      networkStatus = NetworkStatus.setVariables;\n    }\n\n    if (!equal(query.variables, this.variables)) {\n      this.lastDiff = void 0;\n    }\n\n    Object.assign(this, {\n      document: query.document,\n      variables: query.variables,\n      networkError: null,\n      graphQLErrors: this.graphQLErrors || [],\n      networkStatus,\n    });\n\n    if (query.observableQuery) {\n      this.setObservableQuery(query.observableQuery);\n    }\n\n    if (query.lastRequestId) {\n      this.lastRequestId = query.lastRequestId;\n    }\n\n    return this;\n  }\n\n  private dirty: boolean = false;\n\n  private notifyTimeout?: ReturnType<typeof setTimeout>;\n\n  reset() {\n    cancelNotifyTimeout(this);\n    this.dirty = false;\n  }\n\n  getDiff(): Cache.DiffResult<any> {\n    const options = this.getDiffOptions();\n\n    if (this.lastDiff && equal(options, this.lastDiff.options)) {\n      return this.lastDiff.diff;\n    }\n\n    this.updateWatch(this.variables);\n\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return { complete: false };\n    }\n\n    const diff = this.cache.diff(options);\n    this.updateLastDiff(diff, options);\n    return diff;\n  }\n\n  private lastDiff?: {\n    diff: Cache.DiffResult<any>;\n    options: Cache.DiffOptions;\n  };\n\n  private updateLastDiff(\n    diff: Cache.DiffResult<any> | null,\n    options?: Cache.DiffOptions\n  ) {\n    this.lastDiff = diff\n      ? {\n          diff,\n          options: options || this.getDiffOptions(),\n        }\n      : void 0;\n  }\n\n  private getDiffOptions(variables = this.variables): Cache.DiffOptions {\n    return {\n      query: this.document!,\n      variables,\n      returnPartialData: true,\n      optimistic: true,\n      canonizeResults: this.observableQuery?.options.canonizeResults,\n    };\n  }\n\n  setDiff(diff: Cache.DiffResult<any> | null) {\n    const oldDiff = this.lastDiff && this.lastDiff.diff;\n    this.updateLastDiff(diff);\n    if (!this.dirty && !equal(oldDiff && oldDiff.result, diff && diff.result)) {\n      this.dirty = true;\n      if (!this.notifyTimeout) {\n        this.notifyTimeout = setTimeout(() => this.notify(), 0);\n      }\n    }\n  }\n\n  public readonly observableQuery: ObservableQuery<any> | null = null;\n  private oqListener?: QueryListener;\n\n  setObservableQuery(oq: ObservableQuery<any> | null) {\n    if (oq === this.observableQuery) return;\n\n    if (this.oqListener) {\n      this.listeners.delete(this.oqListener);\n    }\n\n    (this as any).observableQuery = oq;\n\n    if (oq) {\n      oq[\"queryInfo\"] = this;\n      this.listeners.add(\n        (this.oqListener = () => {\n          const diff = this.getDiff();\n          if (diff.fromOptimisticTransaction) {\n            // If this diff came from an optimistic transaction, deliver the\n            // current cache data to the ObservableQuery, but don't perform a\n            // reobservation, since oq.reobserveCacheFirst might make a network\n            // request, and we never want to trigger network requests in the\n            // middle of optimistic updates.\n            oq[\"observe\"]();\n          } else {\n            // Otherwise, make the ObservableQuery \"reobserve\" the latest data\n            // using a temporary fetch policy of \"cache-first\", so complete cache\n            // results have a chance to be delivered without triggering additional\n            // network requests, even when options.fetchPolicy is \"network-only\"\n            // or \"cache-and-network\". All other fetch policies are preserved by\n            // this method, and are handled by calling oq.reobserve(). If this\n            // reobservation is spurious, isDifferentFromLastResult still has a\n            // chance to catch it before delivery to ObservableQuery subscribers.\n            reobserveCacheFirst(oq);\n          }\n        })\n      );\n    } else {\n      delete this.oqListener;\n    }\n  }\n\n  notify() {\n    cancelNotifyTimeout(this);\n\n    if (this.shouldNotify()) {\n      this.listeners.forEach((listener) => listener(this));\n    }\n\n    this.dirty = false;\n  }\n\n  private shouldNotify() {\n    if (!this.dirty || !this.listeners.size) {\n      return false;\n    }\n\n    if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {\n      const { fetchPolicy } = this.observableQuery.options;\n      if (fetchPolicy !== \"cache-only\" && fetchPolicy !== \"cache-and-network\") {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public stop() {\n    if (!this.stopped) {\n      this.stopped = true;\n\n      // Cancel the pending notify timeout\n      this.reset();\n\n      this.cancel();\n      // Revert back to the no-op version of cancel inherited from\n      // QueryInfo.prototype.\n      this.cancel = QueryInfo.prototype.cancel;\n\n      const oq = this.observableQuery;\n      if (oq) oq.stopPolling();\n    }\n  }\n\n  // This method is a no-op by default, until/unless overridden by the\n  // updateWatch method.\n  private cancel() {}\n\n  private lastWatch?: Cache.WatchOptions;\n\n  private updateWatch(variables = this.variables) {\n    const oq = this.observableQuery;\n    if (oq && oq.options.fetchPolicy === \"no-cache\") {\n      return;\n    }\n\n    const watchOptions: Cache.WatchOptions = {\n      // Although this.getDiffOptions returns Cache.DiffOptions instead of\n      // Cache.WatchOptions, all the overlapping options should be the same, so\n      // we can reuse getDiffOptions here, for consistency.\n      ...this.getDiffOptions(variables),\n      watcher: this,\n      callback: (diff) => this.setDiff(diff),\n    };\n\n    if (!this.lastWatch || !equal(watchOptions, this.lastWatch)) {\n      this.cancel();\n      this.cancel = this.cache.watch((this.lastWatch = watchOptions));\n    }\n  }\n\n  private lastWrite?: {\n    result: FetchResult<any>;\n    variables: WatchQueryOptions[\"variables\"];\n    dmCount: number | undefined;\n  };\n\n  public resetLastWrite() {\n    this.lastWrite = void 0;\n  }\n\n  private shouldWrite(\n    result: FetchResult<any>,\n    variables: WatchQueryOptions[\"variables\"]\n  ) {\n    const { lastWrite } = this;\n    return !(\n      lastWrite &&\n      // If cache.evict has been called since the last time we wrote this\n      // data into the cache, there's a chance writing this result into\n      // the cache will repair what was evicted.\n      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n      equal(variables, lastWrite.variables) &&\n      equal(result.data, lastWrite.result.data)\n    );\n  }\n\n  public markResult<T>(\n    result: FetchResult<T>,\n    document: DocumentNode,\n    options: Pick<\n      WatchQueryOptions,\n      \"variables\" | \"fetchPolicy\" | \"errorPolicy\"\n    >,\n    cacheWriteBehavior: CacheWriteBehavior\n  ) {\n    const merger = new DeepMerger();\n    const graphQLErrors = isNonEmptyArray(result.errors)\n      ? result.errors.slice(0)\n      : [];\n\n    // Cancel the pending notify timeout (if it exists) to prevent extraneous network\n    // requests. To allow future notify timeouts, diff and dirty are reset as well.\n    this.reset();\n\n    if (\"incremental\" in result && isNonEmptyArray(result.incremental)) {\n      const mergedData = mergeIncrementalData(this.getDiff().result, result);\n      result.data = mergedData;\n\n      // Detect the first chunk of a deferred query and merge it with existing\n      // cache data. This ensures a `cache-first` fetch policy that returns\n      // partial cache data or a `cache-and-network` fetch policy that already\n      // has full data in the cache does not complain when trying to merge the\n      // initial deferred server data with existing cache data.\n    } else if (\"hasNext\" in result && result.hasNext) {\n      const diff = this.getDiff();\n      result.data = merger.merge(diff.result, result.data);\n    }\n\n    this.graphQLErrors = graphQLErrors;\n\n    if (options.fetchPolicy === \"no-cache\") {\n      this.updateLastDiff(\n        { result: result.data, complete: true },\n        this.getDiffOptions(options.variables)\n      );\n    } else if (cacheWriteBehavior !== CacheWriteBehavior.FORBID) {\n      if (shouldWriteResult(result, options.errorPolicy)) {\n        // Using a transaction here so we have a chance to read the result\n        // back from the cache before the watch callback fires as a result\n        // of writeQuery, so we can store the new diff quietly and ignore\n        // it when we receive it redundantly from the watch callback.\n        this.cache.performTransaction((cache) => {\n          if (this.shouldWrite(result, options.variables)) {\n            cache.writeQuery({\n              query: document,\n              data: result.data as T,\n              variables: options.variables,\n              overwrite: cacheWriteBehavior === CacheWriteBehavior.OVERWRITE,\n            });\n\n            this.lastWrite = {\n              result,\n              variables: options.variables,\n              dmCount: destructiveMethodCounts.get(this.cache),\n            };\n          } else {\n            // If result is the same as the last result we received from\n            // the network (and the variables match too), avoid writing\n            // result into the cache again. The wisdom of skipping this\n            // cache write is far from obvious, since any cache write\n            // could be the one that puts the cache back into a desired\n            // state, fixing corruption or missing data. However, if we\n            // always write every network result into the cache, we enable\n            // feuds between queries competing to update the same data in\n            // incompatible ways, which can lead to an endless cycle of\n            // cache broadcasts and useless network requests. As with any\n            // feud, eventually one side must step back from the brink,\n            // letting the other side(s) have the last word(s). There may\n            // be other points where we could break this cycle, such as\n            // silencing the broadcast for cache.writeQuery (not a good\n            // idea, since it just delays the feud a bit) or somehow\n            // avoiding the network request that just happened (also bad,\n            // because the server could return useful new data). All\n            // options considered, skipping this cache write seems to be\n            // the least damaging place to break the cycle, because it\n            // reflects the intuition that we recently wrote this exact\n            // result into the cache, so the cache *should* already/still\n            // contain this data. If some other query has clobbered that\n            // data in the meantime, that's too bad, but there will be no\n            // winners if every query blindly reverts to its own version\n            // of the data. This approach also gives the network a chance\n            // to return new data, which will be written into the cache as\n            // usual, notifying only those queries that are directly\n            // affected by the cache updates, as usual. In the future, an\n            // even more sophisticated cache could perhaps prevent or\n            // mitigate the clobbering somehow, but that would make this\n            // particular cache write even less important, and thus\n            // skipping it would be even safer than it is today.\n            if (this.lastDiff && this.lastDiff.diff.complete) {\n              // Reuse data from the last good (complete) diff that we\n              // received, when possible.\n              result.data = this.lastDiff.diff.result;\n              return;\n            }\n            // If the previous this.diff was incomplete, fall through to\n            // re-reading the latest data with cache.diff, below.\n          }\n\n          const diffOptions = this.getDiffOptions(options.variables);\n          const diff = cache.diff<T>(diffOptions);\n\n          // In case the QueryManager stops this QueryInfo before its\n          // results are delivered, it's important to avoid restarting the\n          // cache watch when markResult is called. We also avoid updating\n          // the watch if we are writing a result that doesn't match the current\n          // variables to avoid race conditions from broadcasting the wrong\n          // result.\n          if (!this.stopped && equal(this.variables, options.variables)) {\n            // Any time we're about to update this.diff, we need to make\n            // sure we've started watching the cache.\n            this.updateWatch(options.variables);\n          }\n\n          // If we're allowed to write to the cache, and we can read a\n          // complete result from the cache, update result.data to be the\n          // result from the cache, rather than the raw network result.\n          // Set without setDiff to avoid triggering a notify call, since\n          // we have other ways of notifying for this result.\n          this.updateLastDiff(diff, diffOptions);\n          if (diff.complete) {\n            result.data = diff.result;\n          }\n        });\n      } else {\n        this.lastWrite = void 0;\n      }\n    }\n  }\n\n  public markReady() {\n    this.networkError = null;\n    return (this.networkStatus = NetworkStatus.ready);\n  }\n\n  public markError(error: ApolloError) {\n    this.networkStatus = NetworkStatus.error;\n    this.lastWrite = void 0;\n\n    this.reset();\n\n    if (error.graphQLErrors) {\n      this.graphQLErrors = error.graphQLErrors;\n    }\n\n    if (error.networkError) {\n      this.networkError = error.networkError;\n    }\n\n    return error;\n  }\n}\n\nexport function shouldWriteResult<T>(\n  result: FetchResult<T>,\n  errorPolicy: ErrorPolicy = \"none\"\n) {\n  const ignoreErrors = errorPolicy === \"ignore\" || errorPolicy === \"all\";\n  let writeWithErrors = !graphQLResultHasError(result);\n  if (!writeWithErrors && ignoreErrors && result.data) {\n    writeWithErrors = true;\n  }\n  return writeWithErrors;\n}\n", "import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { DocumentNode } from \"graphql\";\n// TODO(brian): A hack until this issue is resolved (https://github.com/graphql/graphql-js/issues/3356)\ntype OperationTypeNode = any;\nimport { equal } from \"@wry/equality\";\n\nimport type { ApolloLink, FetchResult } from \"../link/core/index.js\";\nimport { execute } from \"../link/core/index.js\";\nimport {\n  hasDirectives,\n  isExecutionPatchIncrementalResult,\n  isExecutionPatchResult,\n  removeDirectivesFromDocument,\n} from \"../utilities/index.js\";\nimport type { Cache, ApolloCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\n\nimport type {\n  ObservableSubscription,\n  ConcastSourcesArray,\n} from \"../utilities/index.js\";\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  getGraphQLErrorsFromResult,\n  canUseWeakMap,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  makeUniqueId,\n  isDocumentNode,\n  isNonNullObject,\n  DocumentTransform,\n} from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport {\n  ApolloError,\n  isApolloError,\n  graphQLResultHasProtocolErrors,\n} from \"../errors/index.js\";\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n  MutationFetchPolicy,\n} from \"./watchQueryOptions.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport type {\n  ApolloQueryResult,\n  OperationVariables,\n  MutationUpdaterFunction,\n  OnQueryUpdated,\n  InternalRefetchQueriesInclude,\n  InternalRefetchQueriesOptions,\n  InternalRefetchQueriesResult,\n  InternalRefetchQueriesMap,\n} from \"./types.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nimport type { QueryStoreValue } from \"./QueryInfo.js\";\nimport {\n  QueryInfo,\n  shouldWriteResult,\n  CacheWriteBehavior,\n} from \"./QueryInfo.js\";\nimport type { ApolloErrorOptions } from \"../errors/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\n\nconst { hasOwnProperty } = Object.prototype;\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\ntype UpdateQueries<TData> = MutationOptions<TData, any, any>[\"updateQueries\"];\n\ninterface TransformCacheEntry {\n  hasClientExports: boolean;\n  hasForcedResolvers: boolean;\n  hasNonreactiveDirective: boolean;\n  clientQuery: DocumentNode | null;\n  serverQuery: DocumentNode | null;\n  defaultVars: OperationVariables;\n  asQuery: DocumentNode;\n}\n\nimport type { DefaultOptions } from \"./ApolloClient.js\";\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public defaultOptions: DefaultOptions;\n\n  public readonly assumeImmutableResults: boolean;\n  public readonly documentTransform: DocumentTransform;\n  public readonly ssrMode: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    defaultOptions,\n    documentTransform,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults = !!cache.assumeImmutableResults,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    defaultOptions?: DefaultOptions;\n    documentTransform?: DocumentTransform;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    const defaultDocumentTransform = new DocumentTransform(\n      (document) => this.cache.transformDocument(document),\n      // Allow the apollo cache to manage its own transform caches\n      { cache: false }\n    );\n\n    this.cache = cache;\n    this.link = link;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = assumeImmutableResults;\n    this.documentTransform = documentTransform\n      ? defaultDocumentTransform\n          .concat(documentTransform)\n          // The custom document transform may add new fragment spreads or new\n          // field selections, so we want to give the cache a chance to run\n          // again. For example, the InMemoryCache adds __typename to field\n          // selections and fragments from the fragment registry.\n          .concat(defaultDocumentTransform)\n      : defaultDocumentTransform;\n\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      newInvariantError(\"QueryManager stopped while query was in flight\")\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach((cancel) => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<\n    TData,\n    TVariables extends OperationVariables,\n    TContext extends Record<string, any>,\n    TCache extends ApolloCache<any>,\n  >({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    onQueryUpdated,\n    fetchPolicy = this.defaultOptions.mutate?.fetchPolicy || \"network-only\",\n    errorPolicy = this.defaultOptions.mutate?.errorPolicy || \"none\",\n    keepRootFields,\n    context,\n  }: MutationOptions<TData, TVariables, TContext>): Promise<\n    FetchResult<TData>\n  > {\n    invariant(\n      mutation,\n      \"mutation option is required. You must specify your GraphQL document in the mutation option.\"\n    );\n\n    invariant(\n      fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\",\n      \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\"\n    );\n\n    const mutationId = this.generateMutationId();\n\n    mutation = this.cache.transformForLink(this.transform(mutation));\n    const { hasClientExports } = this.getDocumentInfo(mutation);\n\n    variables = this.getVariables(mutation, variables) as TVariables;\n    if (hasClientExports) {\n      variables = (await this.localState.addExportedVariables(\n        mutation,\n        variables,\n        context\n      )) as TVariables;\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    if (optimisticResponse) {\n      this.markMutationOptimistic<TData, TVariables, TContext, TCache>(\n        optimisticResponse,\n        {\n          mutationId,\n          document: mutation,\n          variables,\n          fetchPolicy,\n          errorPolicy,\n          context,\n          updateQueries,\n          update: updateWithProxyFn,\n          keepRootFields,\n        }\n      );\n    }\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      return asyncMap(\n        self.getObservableFromLink(\n          mutation,\n          {\n            ...context,\n            optimisticResponse,\n          },\n          variables,\n          false\n        ),\n\n        (result: FetchResult<TData>) => {\n          if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n            throw new ApolloError({\n              graphQLErrors: getGraphQLErrorsFromResult(result),\n            });\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          const storeResult: typeof result = { ...result };\n\n          if (typeof refetchQueries === \"function\") {\n            refetchQueries = refetchQueries(storeResult);\n          }\n\n          if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n            delete storeResult.errors;\n          }\n\n          return self.markMutationResult<TData, TVariables, TContext, TCache>({\n            mutationId,\n            result: storeResult,\n            document: mutation,\n            variables,\n            fetchPolicy,\n            errorPolicy,\n            context,\n            update: updateWithProxyFn,\n            updateQueries,\n            awaitRefetchQueries,\n            refetchQueries,\n            removeOptimistic: optimisticResponse ? mutationId : void 0,\n            onQueryUpdated,\n            keepRootFields,\n          });\n        }\n      ).subscribe({\n        next(storeResult) {\n          self.broadcastQueries();\n\n          // Since mutations might receive multiple payloads from the\n          // ApolloLink chain (e.g. when used with @defer),\n          // we resolve with a SingleExecutionResult or after the final\n          // ExecutionPatchResult has arrived and we have assembled the\n          // multipart response into a single result.\n          if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n            resolve(storeResult);\n          }\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          reject(\n            err instanceof ApolloError\n              ? err\n              : new ApolloError({\n                  networkError: err,\n                })\n          );\n        },\n      });\n    });\n  }\n\n  public markMutationResult<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      awaitRefetchQueries?: boolean;\n      refetchQueries?: InternalRefetchQueriesInclude;\n      removeOptimistic?: string;\n      onQueryUpdated?: OnQueryUpdated<any>;\n      keepRootFields?: boolean;\n    },\n    cache = this.cache\n  ): Promise<FetchResult<TData>> {\n    let { result } = mutation;\n    const cacheWrites: Cache.WriteOptions[] = [];\n    const skipCache = mutation.fetchPolicy === \"no-cache\";\n\n    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n      if (!isExecutionPatchIncrementalResult(result)) {\n        cacheWrites.push({\n          result: result.data,\n          dataId: \"ROOT_MUTATION\",\n          query: mutation.document,\n          variables: mutation.variables,\n        });\n      }\n      if (\n        isExecutionPatchIncrementalResult(result) &&\n        isNonEmptyArray(result.incremental)\n      ) {\n        const diff = cache.diff<TData>({\n          id: \"ROOT_MUTATION\",\n          // The cache complains if passed a mutation where it expects a\n          // query, so we transform mutations and subscriptions to queries\n          // (only once, thanks to this.transformCache).\n          query: this.getDocumentInfo(mutation.document).asQuery,\n          variables: mutation.variables,\n          optimistic: false,\n          returnPartialData: true,\n        });\n        let mergedData;\n        if (diff.result) {\n          mergedData = mergeIncrementalData(diff.result, result);\n        }\n        if (typeof mergedData !== \"undefined\") {\n          // cast the ExecutionPatchResult to FetchResult here since\n          // ExecutionPatchResult never has `data` when returned from the server\n          (result as FetchResult).data = mergedData;\n          cacheWrites.push({\n            result: mergedData,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables,\n          });\n        }\n      }\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: result,\n              queryName: (document && getOperationName(document)) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: \"ROOT_QUERY\",\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n    }\n\n    if (\n      cacheWrites.length > 0 ||\n      mutation.refetchQueries ||\n      mutation.update ||\n      mutation.onQueryUpdated ||\n      mutation.removeOptimistic\n    ) {\n      const results: any[] = [];\n\n      this.refetchQueries({\n        updateCache: (cache: TCache) => {\n          if (!skipCache) {\n            cacheWrites.forEach((write) => cache.write(write));\n          }\n\n          // If the mutation has some writes associated with it then we need to\n          // apply those writes to the store by running this reducer again with\n          // a write action.\n          const { update } = mutation;\n          // Determine whether result is a SingleExecutionResult,\n          // or the final ExecutionPatchResult.\n          const isFinalResult =\n            !isExecutionPatchResult(result) ||\n            (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n\n          if (update) {\n            if (!skipCache) {\n              // Re-read the ROOT_MUTATION data we just wrote into the cache\n              // (the first cache.write call in the cacheWrites.forEach loop\n              // above), so field read functions have a chance to run for\n              // fields within mutation result objects.\n              const diff = cache.diff<TData>({\n                id: \"ROOT_MUTATION\",\n                // The cache complains if passed a mutation where it expects a\n                // query, so we transform mutations and subscriptions to queries\n                // (only once, thanks to this.transformCache).\n                query: this.getDocumentInfo(mutation.document).asQuery,\n                variables: mutation.variables,\n                optimistic: false,\n                returnPartialData: true,\n              });\n\n              if (diff.complete) {\n                result = { ...(result as FetchResult), data: diff.result };\n                if (\"incremental\" in result) {\n                  delete result.incremental;\n                }\n                if (\"hasNext\" in result) {\n                  delete result.hasNext;\n                }\n              }\n            }\n\n            // If we've received the whole response,\n            // either a SingleExecutionResult or the final ExecutionPatchResult,\n            // call the update function.\n            if (isFinalResult) {\n              update(cache, result, {\n                context: mutation.context,\n                variables: mutation.variables,\n              });\n            }\n          }\n\n          // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n          // shallow to allow rolling back optimistic evictions.\n          if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n            cache.modify({\n              id: \"ROOT_MUTATION\",\n              fields(value, { fieldName, DELETE }) {\n                return fieldName === \"__typename\" ? value : DELETE;\n              },\n            });\n          }\n        },\n\n        include: mutation.refetchQueries,\n\n        // Write the final mutation.result to the root layer of the cache.\n        optimistic: false,\n\n        // Remove the corresponding optimistic layer at the same time as we\n        // write the final non-optimistic result.\n        removeOptimistic: mutation.removeOptimistic,\n\n        // Let the caller of client.mutate optionally determine the refetching\n        // behavior for watched queries after the mutation.update function runs.\n        // If no onQueryUpdated function was provided for this mutation, pass\n        // null instead of undefined to disable the default refetching behavior.\n        onQueryUpdated: mutation.onQueryUpdated || null,\n      }).forEach((result) => results.push(result));\n\n      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n        // Returning a promise here makes the mutation await that promise, so we\n        // include results in that promise's work if awaitRefetchQueries or an\n        // onQueryUpdated function was specified.\n        return Promise.all(results).then(() => result);\n      }\n    }\n\n    return Promise.resolve(result);\n  }\n\n  public markMutationOptimistic<\n    TData,\n    TVariables,\n    TContext,\n    TCache extends ApolloCache<any>,\n  >(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: TVariables;\n      fetchPolicy?: MutationFetchPolicy;\n      errorPolicy: ErrorPolicy;\n      context?: TContext;\n      updateQueries: UpdateQueries<TData>;\n      update?: MutationUpdaterFunction<TData, TVariables, TContext, TCache>;\n      keepRootFields?: boolean;\n    }\n  ) {\n    const data =\n      typeof optimisticResponse === \"function\"\n        ? optimisticResponse(mutation.variables)\n        : optimisticResponse;\n\n    return this.cache.recordOptimisticTransaction((cache) => {\n      try {\n        this.markMutationResult<TData, TVariables, TContext, TCache>(\n          {\n            ...mutation,\n            result: { data },\n          },\n          cache\n        );\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n  }\n\n  public fetchQuery<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n      .promise;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  public transform(document: DocumentNode) {\n    return this.documentTransform.transformDocument(document);\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    TransformCacheEntry\n  >();\n\n  public getDocumentInfo(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cacheEntry: TransformCacheEntry = {\n        // TODO These three calls (hasClientExports, shouldForceResolvers, and\n        // usesNonreactiveDirective) are performing independent full traversals\n        // of the transformed document. We should consider merging these\n        // traversals into a single pass in the future, though the work is\n        // cached after the first time.\n        hasClientExports: hasClientExports(document),\n        hasForcedResolvers: this.localState.shouldForceResolvers(document),\n        hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n        clientQuery: this.localState.clientQuery(document),\n        serverQuery: removeDirectivesFromDocument(\n          [\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" },\n          ],\n          document\n        ),\n        defaultVars: getDefaultValues(\n          getOperationDefinition(document)\n        ) as OperationVariables,\n        // Transform any mutation or subscription operations to query operations\n        // so we can read/write them from/to the cache.\n        asQuery: {\n          ...document,\n          definitions: document.definitions.map((def) => {\n            if (\n              def.kind === \"OperationDefinition\" &&\n              def.operation !== \"query\"\n            ) {\n              return { ...def, operation: \"query\" as OperationTypeNode };\n            }\n            return def;\n          }),\n        },\n      };\n\n      transformCache.set(document, cacheEntry);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables<TVariables>(\n    document: DocumentNode,\n    variables?: TVariables\n  ): OperationVariables {\n    return {\n      ...this.getDocumentInfo(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<\n    T,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    const query = this.transform(options.query);\n\n    // assign variable default values if supplied\n    // NOTE: We don't modify options.query here with the transformed query to\n    // ensure observable.options.query is set to the raw untransformed query.\n    options = {\n      ...options,\n      variables: this.getVariables(query, options.variables) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n    observable[\"lastQuery\"] = query;\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    // We give queryInfo the transformed query to ensure the first cache diff\n    // uses the transformed query instead of the raw query\n    queryInfo.init({\n      document: query,\n      observableQuery: observable,\n      variables: observable.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars extends OperationVariables = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n    queryId = this.generateQueryId()\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      \"query option is required. You must specify your GraphQL document \" +\n        \"in the query option.\"\n    );\n\n    invariant(\n      options.query.kind === \"Document\",\n      'You must wrap the query string in a \"gql\" tag.'\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      \"returnPartialData option only supported on watchQuery.\"\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      \"pollInterval option only supported on watchQuery.\"\n    );\n\n    return this.fetchQuery<TData, TVars>(queryId, {\n      ...options,\n      query: this.transform(options.query),\n    }).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(\n    options: Cache.ResetOptions = {\n      discardWatches: true,\n    }\n  ): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(\n      newInvariantError(\n        \"Store reset while query was in flight (not completed in link chain)\"\n      )\n    );\n\n    this.queries.forEach((queryInfo) => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset(options);\n  }\n\n  public getObservableQueries(\n    include: InternalRefetchQueriesInclude = \"active\"\n  ) {\n    const queries = new Map<string, ObservableQuery<any>>();\n    const queryNamesAndDocs = new Map<string | DocumentNode, boolean>();\n    const legacyQueryOptions = new Set<QueryOptions>();\n\n    if (Array.isArray(include)) {\n      include.forEach((desc) => {\n        if (typeof desc === \"string\") {\n          queryNamesAndDocs.set(desc, false);\n        } else if (isDocumentNode(desc)) {\n          queryNamesAndDocs.set(this.transform(desc), false);\n        } else if (isNonNullObject(desc) && desc.query) {\n          legacyQueryOptions.add(desc);\n        }\n      });\n    }\n\n    this.queries.forEach(({ observableQuery: oq, document }, queryId) => {\n      if (oq) {\n        if (include === \"all\") {\n          queries.set(queryId, oq);\n          return;\n        }\n\n        const {\n          queryName,\n          options: { fetchPolicy },\n        } = oq;\n\n        if (\n          fetchPolicy === \"standby\" ||\n          (include === \"active\" && !oq.hasObservers())\n        ) {\n          return;\n        }\n\n        if (\n          include === \"active\" ||\n          (queryName && queryNamesAndDocs.has(queryName)) ||\n          (document && queryNamesAndDocs.has(document))\n        ) {\n          queries.set(queryId, oq);\n          if (queryName) queryNamesAndDocs.set(queryName, true);\n          if (document) queryNamesAndDocs.set(document, true);\n        }\n      }\n    });\n\n    if (legacyQueryOptions.size) {\n      legacyQueryOptions.forEach((options: QueryOptions) => {\n        // We will be issuing a fresh network request for this query, so we\n        // pre-allocate a new query ID here, using a special prefix to enable\n        // cleaning up these temporary queries later, after fetching.\n        const queryId = makeUniqueId(\"legacyOneTimeQuery\");\n        const queryInfo = this.getQuery(queryId).init({\n          document: options.query,\n          variables: options.variables,\n        });\n        const oq = new ObservableQuery({\n          queryManager: this,\n          queryInfo,\n          options: {\n            ...options,\n            fetchPolicy: \"network-only\",\n          },\n        });\n        invariant(oq.queryId === queryId);\n        queryInfo.setObservableQuery(oq);\n        queries.set(queryId, oq);\n      });\n    }\n\n    if (__DEV__ && queryNamesAndDocs.size) {\n      queryNamesAndDocs.forEach((included, nameOrDoc) => {\n        if (!included) {\n          invariant.warn(\n            typeof nameOrDoc === \"string\"\n              ? `Unknown query named \"%s\" requested in refetchQueries options.include array`\n              : `Unknown query %s requested in refetchQueries options.include array`,\n            nameOrDoc\n          );\n        }\n      });\n    }\n\n    return queries;\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(\n      (observableQuery, queryId) => {\n        const { fetchPolicy } = observableQuery.options;\n        observableQuery.resetLastResults();\n        if (\n          includeStandby ||\n          (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        this.getQuery(queryId).setDiff(null);\n      }\n    );\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy = \"none\",\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query);\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(query, context, variables).map((result) => {\n        if (fetchPolicy !== \"no-cache\") {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: \"ROOT_SUBSCRIPTION\",\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        const hasErrors = graphQLResultHasError(result);\n        const hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n        if (hasErrors || hasProtocolErrors) {\n          const errors: ApolloErrorOptions = {};\n          if (hasErrors) {\n            errors.graphQLErrors = result.errors;\n          }\n          if (hasProtocolErrors) {\n            errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n          }\n\n          // `errorPolicy` is a mechanism for handling GraphQL errors, according\n          // to our documentation, so we throw protocol errors regardless of the\n          // set error policy.\n          if (errorPolicy === \"none\" || hasProtocolErrors) {\n            throw new ApolloError(errors);\n          }\n        }\n\n        if (errorPolicy === \"ignore\") {\n          delete result.errors;\n        }\n\n        return result;\n      });\n\n    if (this.getDocumentInfo(query).hasClientExports) {\n      const observablePromise = this.localState\n        .addExportedVariables(query, variables, context)\n        .then(makeObservable);\n\n      return new Observable<FetchResult<T>>((observer) => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          (observable) => (sub = observable.subscribe(observer)),\n          observer.error\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    if (this.queries.has(queryId)) {\n      this.getQuery(queryId).stop();\n      this.queries.delete(queryId);\n    }\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach((info) => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  // Use protected instead of private field so\n  // @apollo/experimental-nextjs-app-support can access type info.\n  protected inFlightLinkObservables = new Map<\n    string,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    // Prefer context.queryDeduplication if specified.\n    deduplication: boolean = context?.queryDeduplication ??\n      this.queryDeduplication\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery, clientQuery } = this.getDocumentInfo(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication,\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const printedServerQuery = print(serverQuery);\n        const byVariables =\n          inFlightLinkObservables.get(printedServerQuery) || new Map();\n        inFlightLinkObservables.set(printedServerQuery, byVariables);\n\n        const varJson = canonicalStringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>,\n          ]);\n\n          byVariables.set(varJson, (observable = concast));\n\n          concast.beforeNext(() => {\n            if (byVariables.delete(varJson) && byVariables.size < 1) {\n              inFlightLinkObservables.delete(printedServerQuery);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>,\n        ]);\n      }\n    } else {\n      observable = new Concast([Observable.of({ data: {} } as FetchResult<T>)]);\n      context = this.prepareContext(context);\n    }\n\n    if (clientQuery) {\n      observable = asyncMap(observable, (result) => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    cacheWriteBehavior: CacheWriteBehavior,\n    options: Pick<\n      WatchQueryOptions<TVars, TData>,\n      \"query\" | \"variables\" | \"context\" | \"fetchPolicy\" | \"errorPolicy\"\n    >\n  ): Observable<ApolloQueryResult<TData>> {\n    const requestId = (queryInfo.lastRequestId = this.generateRequestId());\n\n    // Performing transformForLink here gives this.cache a chance to fill in\n    // missing fragment definitions (for example) before sending this document\n    // through the link chain.\n    const linkDocument = this.cache.transformForLink(options.query);\n\n    return asyncMap(\n      this.getObservableFromLink(\n        linkDocument,\n        options.context,\n        options.variables\n      ),\n\n      (result) => {\n        const graphQLErrors = getGraphQLErrorsFromResult(result);\n        const hasErrors = graphQLErrors.length > 0;\n\n        // If we interrupted this request by calling getResultsFromLink again\n        // with the same QueryInfo object, we ignore the old results.\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(\n              new ApolloError({\n                graphQLErrors,\n              })\n            );\n          }\n          // Use linkDocument rather than queryInfo.document so the\n          // operation/fragments used to write the result are the same as the\n          // ones used to obtain it from the link.\n          queryInfo.markResult(\n            result,\n            linkDocument,\n            options,\n            cacheWriteBehavior\n          );\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n\n        return aqr;\n      },\n\n      (networkError) => {\n        const error = isApolloError(networkError)\n          ? networkError\n          : new ApolloError({ networkError });\n\n        // Avoid storing errors from older interrupted queries.\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      }\n    );\n  }\n\n  private fetchConcastWithInfo<TData, TVars extends OperationVariables>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n    query = options.query\n  ): ConcastAndInfo<TData> {\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n\n    const defaults = this.defaultOptions.watchQuery;\n    let {\n      fetchPolicy = (defaults && defaults.fetchPolicy) || \"cache-first\",\n      errorPolicy = (defaults && defaults.errorPolicy) || \"none\",\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n\n      const sourcesWithInfo = this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus\n      );\n\n      if (\n        // If we're in standby, postpone advancing options.fetchPolicy using\n        // applyNextFetchPolicy.\n        normalized.fetchPolicy !== \"standby\" &&\n        // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n        // this is another way to detect when nothing was done/fetched.\n        sourcesWithInfo.sources.length > 0 &&\n        queryInfo.observableQuery\n      ) {\n        queryInfo.observableQuery[\"applyNextFetchPolicy\"](\n          \"after-fetch\",\n          options\n        );\n      }\n\n      return sourcesWithInfo;\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    const cleanupCancelFn = () => this.fetchCancelFns.delete(queryId);\n    this.fetchCancelFns.set(queryId, (reason) => {\n      cleanupCancelFn();\n      // This delay ensures the concast variable has been initialized.\n      setTimeout(() => concast.cancel(reason));\n    });\n\n    let concast: Concast<ApolloQueryResult<TData>>,\n      containsDataFromLink: boolean;\n    // If the query has @export(as: ...) directives, then we need to\n    // process those directives asynchronously. When there are no\n    // @export directives (the common case), we deliberately avoid\n    // wrapping the result of this.fetchQueryByPolicy in a Promise,\n    // since the timing of result delivery is (unfortunately) important\n    // for backwards compatibility. TODO This code could be simpler if\n    // we deprecated and removed LocalState.\n    if (this.getDocumentInfo(normalized.query).hasClientExports) {\n      concast = new Concast(\n        this.localState\n          .addExportedVariables(\n            normalized.query,\n            normalized.variables,\n            normalized.context\n          )\n          .then(fromVariables)\n          .then((sourcesWithInfo) => sourcesWithInfo.sources)\n      );\n      // there is just no way we can synchronously get the *right* value here,\n      // so we will assume `true`, which is the behaviour before the bug fix in\n      // #10597. This means that bug is not fixed in that case, and is probably\n      // un-fixable with reasonable effort for the edge case of @export as\n      // directives.\n      containsDataFromLink = true;\n    } else {\n      const sourcesWithInfo = fromVariables(normalized.variables);\n      containsDataFromLink = sourcesWithInfo.fromLink;\n      concast = new Concast(sourcesWithInfo.sources);\n    }\n\n    concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n\n    return {\n      concast,\n      fromLink: containsDataFromLink,\n    };\n  }\n\n  public refetchQueries<TResult>({\n    updateCache,\n    include,\n    optimistic = false,\n    removeOptimistic = optimistic ? makeUniqueId(\"refetchQueries\") : void 0,\n    onQueryUpdated,\n  }: InternalRefetchQueriesOptions<\n    ApolloCache<TStore>,\n    TResult\n  >): InternalRefetchQueriesMap<TResult> {\n    const includedQueriesById = new Map<\n      string,\n      {\n        oq: ObservableQuery<any>;\n        lastDiff?: Cache.DiffResult<any>;\n        diff?: Cache.DiffResult<any>;\n      }\n    >();\n\n    if (include) {\n      this.getObservableQueries(include).forEach((oq, queryId) => {\n        includedQueriesById.set(queryId, {\n          oq,\n          lastDiff: this.getQuery(queryId).getDiff(),\n        });\n      });\n    }\n\n    const results: InternalRefetchQueriesMap<TResult> = new Map();\n\n    if (updateCache) {\n      this.cache.batch({\n        update: updateCache,\n\n        // Since you can perform any combination of cache reads and/or writes in\n        // the cache.batch update function, its optimistic option can be either\n        // a boolean or a string, representing three distinct modes of\n        // operation:\n        //\n        // * false: read/write only the root layer\n        // * true: read/write the topmost layer\n        // * string: read/write a fresh optimistic layer with that ID string\n        //\n        // When typeof optimistic === \"string\", a new optimistic layer will be\n        // temporarily created within cache.batch with that string as its ID. If\n        // we then pass that same string as the removeOptimistic option, we can\n        // make cache.batch immediately remove the optimistic layer after\n        // running the updateCache function, triggering only one broadcast.\n        //\n        // However, the refetchQueries method accepts only true or false for its\n        // optimistic option (not string). We interpret true to mean a temporary\n        // optimistic layer should be created, to allow efficiently rolling back\n        // the effect of the updateCache function, which involves passing a\n        // string instead of true as the optimistic option to cache.batch, when\n        // refetchQueries receives optimistic: true.\n        //\n        // In other words, we are deliberately not supporting the use case of\n        // writing to an *existing* optimistic layer (using the refetchQueries\n        // updateCache function), since that would potentially interfere with\n        // other optimistic updates in progress. Instead, you can read/write\n        // only the root layer by passing optimistic: false to refetchQueries,\n        // or you can read/write a brand new optimistic layer that will be\n        // automatically removed by passing optimistic: true.\n        optimistic: (optimistic && removeOptimistic) || false,\n\n        // The removeOptimistic option can also be provided by itself, even if\n        // optimistic === false, to remove some previously-added optimistic\n        // layer safely and efficiently, like we do in markMutationResult.\n        //\n        // If an explicit removeOptimistic string is provided with optimistic:\n        // true, the removeOptimistic string will determine the ID of the\n        // temporary optimistic layer, in case that ever matters.\n        removeOptimistic,\n\n        onWatchUpdated(watch, diff, lastDiff) {\n          const oq =\n            watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n\n          if (oq) {\n            if (onQueryUpdated) {\n              // Since we're about to handle this query now, remove it from\n              // includedQueriesById, in case it was added earlier because of\n              // options.include.\n              includedQueriesById.delete(oq.queryId);\n\n              let result: TResult | boolean | Promise<ApolloQueryResult<any>> =\n                onQueryUpdated(oq, diff, lastDiff);\n\n              if (result === true) {\n                // The onQueryUpdated function requested the default refetching\n                // behavior by returning true.\n                result = oq.refetch();\n              }\n\n              // Record the result in the results Map, as long as onQueryUpdated\n              // did not return false to skip/ignore this result.\n              if (result !== false) {\n                results.set(\n                  oq,\n                  result as InternalRefetchQueriesResult<TResult>\n                );\n              }\n\n              // Allow the default cache broadcast to happen, except when\n              // onQueryUpdated returns false.\n              return result;\n            }\n\n            if (onQueryUpdated !== null) {\n              // If we don't have an onQueryUpdated function, and onQueryUpdated\n              // was not disabled by passing null, make sure this query is\n              // \"included\" like any other options.include-specified query.\n              includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n            }\n          }\n        },\n      });\n    }\n\n    if (includedQueriesById.size) {\n      includedQueriesById.forEach(({ oq, lastDiff, diff }, queryId) => {\n        let result:\n          | TResult\n          | boolean\n          | Promise<ApolloQueryResult<any>>\n          | undefined;\n\n        // If onQueryUpdated is provided, we want to use it for all included\n        // queries, even the QueryOptions ones.\n        if (onQueryUpdated) {\n          if (!diff) {\n            const info = oq[\"queryInfo\"];\n            info.reset(); // Force info.getDiff() to read from cache.\n            diff = info.getDiff();\n          }\n          result = onQueryUpdated(oq, diff, lastDiff);\n        }\n\n        // Otherwise, we fall back to refetching.\n        if (!onQueryUpdated || result === true) {\n          result = oq.refetch();\n        }\n\n        if (result !== false) {\n          results.set(oq, result as InternalRefetchQueriesResult<TResult>);\n        }\n\n        if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n          this.stopQueryNoBroadcast(queryId);\n        }\n      });\n    }\n\n    if (removeOptimistic) {\n      // In case no updateCache callback was provided (so cache.batch was not\n      // called above, and thus did not already remove the optimistic layer),\n      // remove it here. Since this is a no-op when the layer has already been\n      // removed, we do it even if we called cache.batch above, since it's\n      // possible this.cache is an instance of some ApolloCache subclass other\n      // than InMemoryCache, and does not fully support the removeOptimistic\n      // option for cache.batch.\n      this.cache.removeOptimistic(removeOptimistic);\n    }\n\n    return results;\n  }\n\n  private fetchQueryByPolicy<TData, TVars extends OperationVariables>(\n    queryInfo: QueryInfo,\n    {\n      query,\n      variables,\n      fetchPolicy,\n      refetchWritePolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n      notifyOnNetworkStatusChange,\n    }: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus\n  ): SourcesAndInfo<TData> {\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff();\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading\n    ) => {\n      const data = diff.result;\n\n      if (__DEV__ && !returnPartialData && !equal(data, {})) {\n        logMissingFieldErrors(diff.missing);\n      }\n\n      const fromData = (data: TData | undefined) =>\n        Observable.of({\n          data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus,\n          ...(diff.complete ? null : { partial: true }),\n        } as ApolloQueryResult<TData>);\n\n      if (data && this.getDocumentInfo(query).hasForcedResolvers) {\n        return this.localState\n          .runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true,\n          })\n          .then((resolved) => fromData(resolved.data || void 0));\n      }\n\n      // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n      // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n      // data was incorrectly returned from the cache on refetch:\n      // if diff.missing exists, we should not return cache data.\n      if (\n        errorPolicy === \"none\" &&\n        networkStatus === NetworkStatus.refetch &&\n        Array.isArray(diff.missing)\n      ) {\n        return fromData(void 0);\n      }\n\n      return fromData(data);\n    };\n\n    const cacheWriteBehavior =\n      fetchPolicy === \"no-cache\"\n        ? CacheWriteBehavior.FORBID\n        : // Watched queries must opt into overwriting existing data on refetch,\n        // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n        networkStatus === NetworkStatus.refetch &&\n          refetchWritePolicy !== \"merge\"\n        ? CacheWriteBehavior.OVERWRITE\n        : CacheWriteBehavior.MERGE;\n\n    const resultsFromLink = () =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, cacheWriteBehavior, {\n        query,\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    const shouldNotify =\n      notifyOnNetworkStatusChange &&\n      typeof oldNetworkStatus === \"number\" &&\n      oldNetworkStatus !== networkStatus &&\n      isNetworkRequestInFlight(networkStatus);\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\": {\n        const diff = readCache();\n\n        if (diff.complete) {\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(diff, queryInfo.markReady())],\n          };\n        }\n\n        if (returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-and-network\": {\n        const diff = readCache();\n\n        if (diff.complete || returnPartialData || shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(diff), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n      }\n\n      case \"cache-only\":\n        return {\n          fromLink: false,\n          sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n        };\n\n      case \"network-only\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            sources: [resultsFromCache(readCache()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"no-cache\":\n        if (shouldNotify) {\n          return {\n            fromLink: true,\n            // Note that queryInfo.getDiff() for no-cache queries does not call\n            // cache.diff, but instead returns a { complete: false } stub result\n            // when there is no queryInfo.diff already defined.\n            sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n          };\n        }\n\n        return { fromLink: true, sources: [resultsFromLink()] };\n\n      case \"standby\":\n        return { fromLink: false, sources: [] };\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this, queryId));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n\n// Return types used by fetchQueryByPolicy and other private methods above.\ninterface FetchConcastInfo {\n  // Metadata properties that can be returned in addition to the Concast.\n  fromLink: boolean;\n}\ninterface SourcesAndInfo<TData> extends FetchConcastInfo {\n  sources: ConcastSourcesArray<ApolloQueryResult<TData>>;\n}\ninterface ConcastAndInfo<TData> extends FetchConcastInfo {\n  concast: Concast<ApolloQueryResult<TData>>;\n}\n", "import { invariant, newInvariantError } from \"../utilities/globals/index.js\";\n\nimport type { ExecutionResult, DocumentNode } from \"graphql\";\n\nimport type { FetchResult, GraphQLRequest } from \"../link/core/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport type { ApolloCache, DataProxy, Reference } from \"../cache/index.js\";\nimport type { DocumentTransform, Observable } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport type { UriFunction } from \"../link/http/index.js\";\nimport { HttpLink } from \"../link/http/index.js\";\n\nimport { QueryManager } from \"./QueryManager.js\";\nimport type { ObservableQuery } from \"./ObservableQuery.js\";\n\nimport type {\n  ApolloQueryResult,\n  DefaultContext,\n  OperationVariables,\n  Resolvers,\n  RefetchQueriesOptions,\n  RefetchQueriesResult,\n  InternalRefetchQueriesResult,\n  RefetchQueriesInclude,\n} from \"./types.js\";\n\nimport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from \"./watchQueryOptions.js\";\n\nimport type { FragmentMatcher } from \"./LocalState.js\";\nimport { LocalState } from \"./LocalState.js\";\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any, any>>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  uri?: string | UriFunction;\n  credentials?: string;\n  headers?: Record<string, string>;\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n  documentTransform?: DocumentTransform;\n};\n\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nexport { mergeOptions };\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions;\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>[\"typeDefs\"];\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param uri The GraphQL endpoint that Apollo Client will connect to. If\n   *            `link` is configured, this option is ignored.\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    if (!options.cache) {\n      throw newInvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n          \"in the options object. \\n\" +\n          \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      documentTransform,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      // Expose the client instance as window.__APOLLO_CLIENT__ and call\n      // onBroadcast in queryManager.broadcastQueries to enable browser\n      // devtools, but disable them by default in production.\n      connectToDevTools = typeof window === \"object\" &&\n        !(window as any).__APOLLO_CLIENT__ &&\n        __DEV__,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = cache.assumeImmutableResults,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link = uri\n        ? new HttpLink({ uri, credentials, headers })\n        : ApolloLink.empty();\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || Object.create(null);\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      defaultOptions: this.defaultOptions,\n      documentTransform,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: connectToDevTools\n        ? () => {\n            if (this.devToolsHookCb) {\n              this.devToolsHookCb({\n                action: {},\n                state: {\n                  queries: this.queryManager.getQueryStore(),\n                  mutations: this.queryManager.mutationStore || {},\n                },\n                dataWithOptimisticResults: this.cache.extract(true),\n              });\n            }\n          }\n        : void 0,\n    });\n\n    if (connectToDevTools) this.connectToDevTools();\n  }\n\n  private connectToDevTools() {\n    if (typeof window === \"object\") {\n      type DevToolsConnector = {\n        push(client: ApolloClient<any>): void;\n      };\n      const windowWithDevTools = window as Window & {\n        [devtoolsSymbol]?: DevToolsConnector;\n        __APOLLO_CLIENT__?: ApolloClient<any>;\n      };\n      const devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n      (windowWithDevTools[devtoolsSymbol] =\n        windowWithDevTools[devtoolsSymbol] || ([] as DevToolsConnector)).push(\n        this\n      );\n      windowWithDevTools.__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && __DEV__) {\n      hasSuggestedDevtools = true;\n      setTimeout(() => {\n        if (\n          typeof window !== \"undefined\" &&\n          window.document &&\n          window.top === window.self &&\n          !(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__\n        ) {\n          const nav = window.navigator;\n          const ua = nav && nav.userAgent;\n          let url: string | undefined;\n          if (typeof ua === \"string\") {\n            if (ua.indexOf(\"Chrome/\") > -1) {\n              url =\n                \"https://chrome.google.com/webstore/detail/\" +\n                \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n            } else if (ua.indexOf(\"Firefox/\") > -1) {\n              url =\n                \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n            }\n          }\n          if (url) {\n            invariant.log(\n              \"Download the Apollo DevTools for a better development \" +\n                \"experience: %s\",\n              url\n            );\n          }\n        }\n      }, 10000);\n    }\n  }\n\n  /**\n   * The `DocumentTransform` used to modify GraphQL documents before a request\n   * is made. If a custom `DocumentTransform` is not provided, this will be the\n   * default document transform.\n   */\n  get documentTransform() {\n    return this.queryManager.documentTransform;\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   *\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   *\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifier, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   *\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   *\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: WatchQueryOptions<TVariables, T>): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === \"network-only\" ||\n        options.fetchPolicy === \"cache-and-network\")\n    ) {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: QueryOptions<TVariables, T>): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== \"cache-and-network\",\n      \"The cache-and-network fetchPolicy does not work with client.query, because \" +\n        \"client.query can only return a single result. Please use client.watchQuery \" +\n        \"to receive multiple results from the cache and the network, or consider \" +\n        \"using a different fetchPolicy, such as cache-first or network-only.\"\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n      options = { ...options, fetchPolicy: \"cache-first\" };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n    TContext extends Record<string, any> = DefaultContext,\n    TCache extends ApolloCache<any> = ApolloCache<any>,\n  >(\n    options: MutationOptions<TData, TVariables, TContext>\n  ): Promise<FetchResult<TData>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<TData, TVariables, TContext, TCache>(\n      options\n    );\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<\n    T = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: SubscriptionOptions<TVariables, T>): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeQuery<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>\n  ): Reference | undefined {\n    const ref = this.cache.writeFragment<TData, TVariables>(options);\n\n    if (options.broadcast !== false) {\n      this.queryManager.broadcastQueries();\n    }\n\n    return ref;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: false,\n        })\n      )\n      .then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() =>\n        this.queryManager.clearStore({\n          discardWatches: true,\n        })\n      )\n      .then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(\n        (c) => c !== cb\n      );\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n   *\n   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n   *\n   * It is important to remember that `refetchQueries()` *will* refetch specified active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public refetchQueries<\n    TCache extends ApolloCache<any> = ApolloCache<TCacheShape>,\n    TResult = Promise<ApolloQueryResult<any>>,\n  >(\n    options: RefetchQueriesOptions<TCache, TResult>\n  ): RefetchQueriesResult<TResult> {\n    const map = this.queryManager.refetchQueries(options);\n    const queries: ObservableQuery<any>[] = [];\n    const results: InternalRefetchQueriesResult<TResult>[] = [];\n\n    map.forEach((result, obsQuery) => {\n      queries.push(obsQuery);\n      results.push(result);\n    });\n\n    const result = Promise.all<TResult>(\n      results as TResult[]\n    ) as RefetchQueriesResult<TResult>;\n\n    // In case you need the raw results immediately, without awaiting\n    // Promise.all(results):\n    result.queries = queries;\n    result.results = results;\n\n    // If you decide to ignore the result Promise because you're using\n    // result.queries and result.results instead, you shouldn't have to worry\n    // about preventing uncaught rejections for the Promise.all result.\n    result.catch((error) => {\n      invariant.debug(\n        `In client.refetchQueries, Promise.all promise rejected with error %o`,\n        error\n      );\n    });\n\n    return result;\n  }\n\n  /**\n   * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n   * query ID strings.\n   *\n   * An \"active\" query is one that has observers and a `fetchPolicy` other than\n   * \"standby\" or \"cache-only\".\n   *\n   * You can include all `ObservableQuery` objects (including the inactive ones)\n   * by passing \"all\" instead of \"active\", or you can include just a subset of\n   * active queries by passing an array of query names or DocumentNode objects.\n   */\n  public getObservableQueries(\n    include: RefetchQueriesInclude = \"active\"\n  ): Map<string, ObservableQuery<any>> {\n    return this.queryManager.getObservableQueries(include);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n}\n", "import { parse } from 'graphql';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  Location,\n} from 'graphql/language/ast';\n\n// A map docString -> graphql document\nconst docCache = new Map<string, DocumentNode>();\n\n// A map fragmentName -> [normalized source]\nconst fragmentSourceMap = new Map<string, Set<string>>();\n\nlet printFragmentWarnings = true;\nlet experimentalFragmentVariables = false;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string: string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc: Location) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nfunction processFragments(ast: DocumentNode) {\n  const seenKeys = new Set<string>();\n  const definitions: DefinitionNode[] = [];\n\n  ast.definitions.forEach(fragmentDefinition => {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc!);\n\n      // We know something about this fragment\n      let sourceKeySet = fragmentSourceMap.get(fragmentName)!;\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n\n  return {\n    ...ast,\n    definitions,\n  };\n}\n\nfunction stripLoc(doc: DocumentNode) {\n  const workSet = new Set<Record<string, any>>(doc.definitions);\n\n  workSet.forEach(node => {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(key => {\n      const value = node[key];\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n\n  const loc = doc.loc as Record<string, any>;\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source: string) {\n  var cacheKey = normalize(source);\n  if (!docCache.has(cacheKey)) {\n    const parsed = parse(source, {\n      experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables,\n    } as any);\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n    docCache.set(\n      cacheKey,\n      // check that all \"new\" fragments inside the documents are consistent with\n      // existing fragments of the same name\n      stripLoc(processFragments(parsed)),\n    );\n  }\n  return docCache.get(cacheKey)!;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nexport function gql(\n  literals: string | readonly string[],\n  ...args: any[]\n) {\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  let result = literals[0];\n\n  args.forEach((arg, i) => {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n    result += literals[i + 1];\n  });\n\n  return parseDocument(result);\n}\n\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\n\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\nconst extras = {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n};\n\nexport namespace gql {\n  export const {\n    gql,\n    resetCaches,\n    disableFragmentWarnings,\n    enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables,\n  } = extras;\n}\n\ngql.default = gql;\n\nexport default gql;\n", "/* Core */\n\nexport type { ApolloClientOptions, DefaultOptions } from \"./ApolloClient.js\";\nexport { ApolloClient, mergeOptions } from \"./ApolloClient.js\";\nexport type {\n  FetchMoreOptions,\n  UpdateQueryOptions,\n} from \"./ObservableQuery.js\";\nexport { ObservableQuery } from \"./ObservableQuery.js\";\nexport type {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  FetchPolicy,\n  WatchQueryFetchPolicy,\n  ErrorPolicy,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n} from \"./watchQueryOptions.js\";\nexport { NetworkStatus, isNetworkRequestSettled } from \"./networkStatus.js\";\nexport * from \"./types.js\";\nexport type { Resolver, FragmentMatcher } from \"./LocalState.js\";\nexport { isApolloError, ApolloError } from \"../errors/index.js\";\n/* Cache */\n\nexport type {\n  // All the exports (types) from ../cache, minus cacheSlot,\n  // which we want to keep semi-private.\n  Transaction,\n  DataProxy,\n  InMemoryCacheConfig,\n  ReactiveVar,\n  TypePolicies,\n  TypePolicy,\n  FieldPolicy,\n  FieldReadFunction,\n  FieldMergeFunction,\n  FieldFunctionOptions,\n  PossibleTypesMap,\n} from \"../cache/index.js\";\nexport {\n  Cache,\n  ApolloCache,\n  InMemoryCache,\n  MissingFieldError,\n  defaultDataIdFromObject,\n  makeVar,\n} from \"../cache/index.js\";\n\nexport * from \"../cache/inmemory/types.js\";\n\n/* Link */\n\nexport * from \"../link/core/index.js\";\nexport * from \"../link/http/index.js\";\nexport type { ServerError } from \"../link/utils/index.js\";\nexport {\n  fromError,\n  toPromise,\n  fromPromise,\n  throwServerError,\n} from \"../link/utils/index.js\";\n\n/* Utilities */\n\nexport type {\n  DocumentTransformCacheKey,\n  Observer,\n  ObservableSubscription,\n  Reference,\n  StoreObject,\n} from \"../utilities/index.js\";\nexport {\n  DocumentTransform,\n  Observable,\n  isReference,\n  makeReference,\n} from \"../utilities/index.js\";\n\n/* Supporting */\n\n// The verbosity of invariant.{log,warn,error} can be controlled globally\n// (for anyone using the same ts-invariant package) by passing \"log\",\n// \"warn\", \"error\", or \"silent\" to setVerbosity (\"log\" is the default).\n// Note that all invariant.* logging is hidden in production.\nimport { setVerbosity } from \"ts-invariant\";\nexport { setVerbosity as setLogVerbosity };\nsetVerbosity(__DEV__ ? \"log\" : \"silent\");\n\n// Note that importing `gql` by itself, then destructuring\n// additional properties separately before exporting, is intentional.\n// Due to the way the `graphql-tag` library is setup, certain bundlers\n// can't find the properties added to the exported `gql` function without\n// additional guidance (e.g. Rollup - see\n// https://rollupjs.org/guide/en/#error-name-is-not-exported-by-module).\n// Instead of having people that are using bundlers with `@apollo/client` add\n// extra bundler config to help `graphql-tag` exports be found (which would be\n// awkward since they aren't importing `graphql-tag` themselves), this\n// workaround of pulling the extra properties off the `gql` function,\n// then re-exporting them separately, helps keeps bundlers happy without any\n// additional config changes.\nexport {\n  gql,\n  resetCaches,\n  disableFragmentWarnings,\n  enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables,\n} from \"graphql-tag\";\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloConsumerProps {\n  children: (client: ApolloClient<object>) => React.ReactChild | null;\n}\n\nexport const ApolloConsumer: React.FC<ApolloConsumerProps> = (props) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context: any) => {\n        invariant(\n          context && context.client,\n          'Could not find \"client\" in the context of ApolloConsumer. ' +\n            \"Wrap the root component in an <ApolloProvider>.\"\n        );\n        return props.children(context.client);\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n", "import * as React from \"react\";\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { canUseSymbol } from \"../../utilities/index.js\";\nimport type { RenderPromises } from \"../ssr/index.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: RenderPromises;\n}\n\n// To make sure Apollo Client doesn't create more than one React context\n// (which can lead to problems like having an Apollo Client instance added\n// in one context, then attempting to retrieve it from another different\n// context), a single Apollo context is created and tracked in global state.\nconst contextKey = canUseSymbol\n  ? Symbol.for(\"__APOLLO_CONTEXT__\")\n  : \"__APOLLO_CONTEXT__\";\n\nexport function getApolloContext(): React.Context<ApolloContextValue> {\n  invariant(\n    \"createContext\" in React,\n    \"Invoking `getApolloContext` in an environment where `React.createContext` is not available.\\n\" +\n      \"The Apollo Client functionality you are trying to use is only available in React Client Components.\\n\" +\n      'Please make sure to add \"use client\" at the top of your file.\\n' +\n      // TODO: change to React documentation once React documentation contains information about Client Components\n      \"For more information, see https://nextjs.org/docs/getting-started/react-essentials#client-components\"\n  );\n\n  let context = (React.createContext as any)[\n    contextKey\n  ] as React.Context<ApolloContextValue>;\n  if (!context) {\n    Object.defineProperty(React.createContext, contextKey, {\n      value: (context = React.createContext<ApolloContextValue>({})),\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n    context.displayName = \"ApolloContext\";\n  }\n  return context;\n}\n\n/**\n * @deprecated This function has no \"resetting\" effect since Apollo Client 3.4.12,\n * and will be removed in the next major version of Apollo Client.\n * If you want to get the Apollo Context, use `getApolloContext` instead.\n */\nexport const resetApolloContext = getApolloContext;\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"react\";\n\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children,\n}) => {\n  const ApolloContext = getApolloContext();\n  const parentContext = React.useContext(ApolloContext);\n\n  const context = React.useMemo(() => {\n    return {\n      ...parentContext,\n      client: client || parentContext.client,\n    };\n  }, [parentContext, client]);\n\n  invariant(\n    context.client,\n    \"ApolloProvider was not passed a client instance. Make \" +\n      'sure you pass in your client via the \"client\" prop.'\n  );\n\n  return (\n    <ApolloContext.Provider value={context}>{children}</ApolloContext.Provider>\n  );\n};\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport type { ApolloClient } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\n\nexport function useApolloClient(\n  override?: ApolloClient<object>\n): ApolloClient<object> {\n  const context = React.useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n      \"Wrap the root component in an <ApolloProvider>, or pass an ApolloClient \" +\n      \"instance in via options.\"\n  );\n\n  return client;\n}\n", "import type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport * as React from \"react\";\n\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type {\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  NoInfer,\n  QueryResult,\n} from \"../types/types.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"reobserve\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"subscribeToMore\",\n] as const;\n\nexport function useLazyQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef =\n    React.useRef<Partial<LazyQueryHookExecOptions<TData, TVariables>>>();\n  const optionsRef = React.useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = React.useRef<\n    DocumentNode | TypedDocumentNode<TData, TVariables>\n  >();\n  const merged = mergeOptions(options, execOptionsRef.current || {});\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute`\n  // function remains referentially stable between renders.\n  optionsRef.current = merged;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current,\n  });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdateState();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = React.useCallback<LazyQueryResultTuple<TData, TVariables>[0]>(\n    (executeOptions) => {\n      execOptionsRef.current = executeOptions\n        ? {\n            ...executeOptions,\n            fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n          }\n        : {\n            fetchPolicy: initialFetchPolicy,\n          };\n\n      const options = mergeOptions(optionsRef.current, {\n        query: queryRef.current,\n        ...execOptionsRef.current,\n      });\n\n      const promise = internalState\n        .executeQuery({ ...options, skip: false })\n        .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n      // Because the return value of `useLazyQuery` is usually floated, we need\n      // to catch the promise to prevent unhandled rejections.\n      promise.catch(() => {});\n\n      return promise;\n    },\n    []\n  );\n\n  return [execute, result];\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"react\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type { ApolloContextValue } from \"../context/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport type {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  canUseWeakMap,\n  compact,\n  isNonEmptyArray,\n  maybeDeepFreeze,\n} from \"../../utilities/index.js\";\n\nconst {\n  prototype: { hasOwnProperty },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n): QueryResult<TData, TVariables> {\n  return useInternalState(useApolloClient(options.client), query).useQuery(\n    options\n  );\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>\n): InternalState<TData, TVariables> {\n  const stateRef = React.useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  state.forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n  forceUpdateState() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\n      \"Calling default no-op implementation of InternalState#forceUpdate\"\n    );\n  }\n\n  /**\n   * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n   * whenever it is available and reset to `forceUpdateState` when it isn't.\n   */\n  forceUpdate = () => this.forceUpdateState();\n\n  executeQuery(\n    options: QueryHookOptions<TData, TVariables> & {\n      query?: DocumentNode;\n    }\n  ) {\n    if (options.query) {\n      Object.assign(this, { query: options.query });\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    const concast = this.observable.reobserveAsConcast(\n      this.getObsQueryOptions()\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = this.result?.data || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n\n    return new Promise<QueryResult<TData, TVariables>>((resolve) => {\n      let result: ApolloQueryResult<TData>;\n\n      // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: (value) => {\n          result = value;\n        },\n        error: () => {\n          resolve(this.toQueryResult(this.observable.getCurrentResult()));\n        },\n        complete: () => {\n          resolve(this.toQueryResult(result));\n        },\n      });\n    });\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      React.useCallback(\n        (handleStoreChange) => {\n          if (this.renderPromises) {\n            return () => {};\n          }\n\n          this.forceUpdate = handleStoreChange;\n\n          const onNext = () => {\n            const previousResult = this.result;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            const result = obsQuery.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (\n              previousResult &&\n              previousResult.loading === result.loading &&\n              previousResult.networkStatus === result.networkStatus &&\n              equal(previousResult.data, result.data)\n            ) {\n              return;\n            }\n\n            this.setResult(result);\n          };\n\n          const onError = (error: Error) => {\n            subscription.unsubscribe();\n            subscription = obsQuery.resubscribeAfterError(onNext, onError);\n\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n              // The error is not a GraphQL error\n              throw error;\n            }\n\n            const previousResult = this.result;\n            if (\n              !previousResult ||\n              (previousResult && previousResult.loading) ||\n              !equal(error, previousResult.error)\n            ) {\n              this.setResult({\n                data: (previousResult && previousResult.data) as TData,\n                error: error as ApolloError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n              });\n            }\n          };\n\n          let subscription = obsQuery.subscribe(onNext, onError);\n\n          // Do the \"unsubscribe\" with a short delay.\n          // This way, an existing subscription can be reused without an additional\n          // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n          // happen in very fast succession.\n          return () => {\n            setTimeout(() => subscription.unsubscribe());\n            this.forceUpdate = () => this.forceUpdateState();\n          };\n        },\n        [\n          // We memoize the subscribe function using useCallback and the following\n          // dependency keys, because the subscribe function reference is all that\n          // useSyncExternalStore uses internally as a dependency key for the\n          // useEffect ultimately responsible for the subscription, so we are\n          // effectively passing this dependency array to that useEffect buried\n          // inside useSyncExternalStore, as desired.\n          obsQuery,\n          this.renderPromises,\n          this.client.disableNetworkFetches,\n        ]\n      ),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult()\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(options: QueryHookOptions<TData, TVariables>) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted =\n      options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === \"standby\"\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<Partial<WatchQueryOptions<TVariables, TData>>> = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(\n      compact(\n        this.observable && this.observable.options,\n        this.watchQueryOptions\n      )\n    );\n\n    return toMerge.reduce(mergeOptions) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<\n    TVariables,\n    TData\n  > {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (watchQueryOptions.fetchPolicy === \"network-only\" ||\n        watchQueryOptions.fetchPolicy === \"cache-and-network\")\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: \"standby\",\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = (this.observable =\n      (this.renderPromises &&\n        this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\n      this.observable || // Reuse this.observable if possible (and not SSR)\n      this.client.watchQuery(this.getObsQueryOptions()));\n\n    this.obsQueryFields = React.useMemo(\n      () => ({\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n      }),\n      [obsQuery]\n    );\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false || this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  }\n\n  private handleErrorOrCompleted(\n    result: ApolloQueryResult<TData>,\n    previousResult?: ApolloQueryResult<TData>\n  ) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve()\n        .then(() => {\n          if (error) {\n            this.onError(error);\n          } else if (\n            result.data &&\n            previousResult?.networkStatus !== result.networkStatus &&\n            result.networkStatus === NetworkStatus.ready\n          ) {\n            this.onCompleted(result.data);\n          }\n        })\n        .catch((error) => {\n          invariant.warn(error);\n        });\n    }\n  }\n\n  private toApolloError(\n    result: ApolloQueryResult<TData>\n  ): ApolloError | undefined {\n    return isNonEmptyArray(result.errors)\n      ? new ApolloError({ graphQLErrors: result.errors })\n      : result.error;\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        (this.result = this.observable.getCurrentResult())\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(\n      result,\n      (queryResult = {\n        data, // Ensure always defined, even if result.data is missing.\n        ...resultWithoutPartial,\n        ...this.obsQueryFields,\n        client: this.client,\n        observable: this.observable,\n        variables: this.observable.variables,\n        called: !this.queryHookOptions.skip,\n        previousData: this.previousData,\n      })\n    );\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== \"cache-only\"\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\n\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\n\nimport type {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n} from \"graphql\";\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription,\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = \"Query\";\n      break;\n    case DocumentType.Mutation:\n      name = \"Mutation\";\n      break;\n    case DocumentType.Subscription:\n      name = \"Subscription\";\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to safety check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of %s passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`,\n    document\n  );\n\n  const fragments: DefinitionNode[] = [];\n  const queries: DefinitionNode[] = [];\n  const mutations: DefinitionNode[] = [];\n  const subscriptions: DefinitionNode[] = [];\n\n  for (const x of document.definitions) {\n    if (x.kind === \"FragmentDefinition\") {\n      fragments.push(x);\n      continue;\n    }\n\n    if (x.kind === \"OperationDefinition\") {\n      switch (x.operation) {\n        case \"query\":\n          queries.push(x);\n          break;\n        case \"mutation\":\n          mutations.push(x);\n          break;\n        case \"subscription\":\n          subscriptions.push(x);\n          break;\n      }\n    }\n  }\n\n  invariant(\n    !fragments.length ||\n      queries.length ||\n      mutations.length ||\n      subscriptions.length,\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `%s had %s queries, %s ` +\n      `subscriptions and %s mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    queries.length,\n    subscriptions.length,\n    mutations.length\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. %s had ` +\n      `%s definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`,\n    document,\n    definitions.length\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === \"Name\") {\n    name = definition.name.value;\n  } else {\n    name = \"data\"; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n\nexport function verifyDocumentType(document: DocumentNode, type: DocumentType) {\n  const operation = parser(document);\n  const requiredOperationName = operationName(type);\n  const usedOperationName = operationName(operation.type);\n  invariant(\n    operation.type === type,\n    `Running a %s requires a graphql ` + `%s, but a %s was used instead.`,\n    requiredOperationName,\n    requiredOperationName,\n    usedOperationName\n  );\n}\n", "import * as React from \"react\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport type {\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport type {\n  ApolloCache,\n  DefaultContext,\n  OperationVariables,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport function useMutation<\n  TData = any,\n  TVariables = OperationVariables,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: MutationHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>,\n    TContext,\n    TCache\n  >\n): MutationTuple<TData, TVariables, TContext, TCache> {\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(mutation, DocumentType.Mutation);\n  const [result, setResult] = React.useState<Omit<MutationResult, \"reset\">>({\n    called: false,\n    loading: false,\n    client,\n  });\n\n  const ref = React.useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  // TODO: Trying to assign these in a useEffect or useLayoutEffect breaks\n  // higher-order components.\n  {\n    Object.assign(ref.current, { client, options, mutation });\n  }\n\n  const execute = React.useCallback(\n    (\n      executeOptions: MutationFunctionOptions<\n        TData,\n        TVariables,\n        TContext,\n        TCache\n      > = {}\n    ) => {\n      const { options, mutation } = ref.current;\n      const baseOptions = { ...options, mutation };\n      const client = executeOptions.client || ref.current.client;\n\n      if (\n        !ref.current.result.loading &&\n        !baseOptions.ignoreResults &&\n        ref.current.isMounted\n      ) {\n        setResult(\n          (ref.current.result = {\n            loading: true,\n            error: void 0,\n            data: void 0,\n            called: true,\n            client,\n          })\n        );\n      }\n\n      const mutationId = ++ref.current.mutationId;\n      const clientOptions = mergeOptions(baseOptions, executeOptions as any);\n\n      return client\n        .mutate(clientOptions)\n        .then((response) => {\n          const { data, errors } = response;\n          const error =\n            errors && errors.length > 0\n              ? new ApolloError({ graphQLErrors: errors })\n              : void 0;\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (error && onError) {\n            onError(error, clientOptions);\n          }\n\n          if (\n            mutationId === ref.current.mutationId &&\n            !clientOptions.ignoreResults\n          ) {\n            const result = {\n              called: true,\n              loading: false,\n              data,\n              error,\n              client,\n            };\n\n            if (ref.current.isMounted && !equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onCompleted =\n            executeOptions.onCompleted || ref.current.options?.onCompleted;\n\n          if (!error) {\n            onCompleted?.(response.data!, clientOptions);\n          }\n\n          return response;\n        })\n        .catch((error) => {\n          if (mutationId === ref.current.mutationId && ref.current.isMounted) {\n            const result = {\n              loading: false,\n              error,\n              data: void 0,\n              called: true,\n              client,\n            };\n\n            if (!equal(ref.current.result, result)) {\n              setResult((ref.current.result = result));\n            }\n          }\n\n          const onError =\n            executeOptions.onError || ref.current.options?.onError;\n\n          if (onError) {\n            onError(error, clientOptions);\n\n            // TODO(brian): why are we returning this here???\n            return { data: void 0, errors: error };\n          }\n\n          throw error;\n        });\n    },\n    []\n  );\n\n  const reset = React.useCallback(() => {\n    if (ref.current.isMounted) {\n      setResult({ called: false, loading: false, client });\n    }\n  }, []);\n\n  React.useEffect(() => {\n    ref.current.isMounted = true;\n\n    return () => {\n      ref.current.isMounted = false;\n    };\n  }, []);\n\n  return [execute, { reset, ...result }];\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"react\";\nimport type { DocumentNode } from \"graphql\";\nimport type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  NoInfer,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n} from \"../types/types.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport function useSubscription<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SubscriptionHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  const hasIssuedDeprecationWarningRef = React.useRef(false);\n  const client = useApolloClient(options?.client);\n  verifyDocumentType(subscription, DocumentType.Subscription);\n  const [result, setResult] = React.useState<\n    SubscriptionResult<TData, TVariables>\n  >({\n    loading: !options?.skip,\n    error: void 0,\n    data: void 0,\n    variables: options?.variables,\n  });\n\n  if (!hasIssuedDeprecationWarningRef.current) {\n    hasIssuedDeprecationWarningRef.current = true;\n\n    if (options?.onSubscriptionData) {\n      invariant.warn(\n        options.onData\n          ? \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n          : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\"\n      );\n    }\n\n    if (options?.onSubscriptionComplete) {\n      invariant.warn(\n        options.onComplete\n          ? \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n          : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\"\n      );\n    }\n  }\n\n  const [observable, setObservable] = React.useState(() => {\n    if (options?.skip) {\n      return null;\n    }\n\n    return client.subscribe({\n      query: subscription,\n      variables: options?.variables,\n      fetchPolicy: options?.fetchPolicy,\n      context: options?.context,\n    });\n  });\n\n  const canResetObservableRef = React.useRef(false);\n  React.useEffect(() => {\n    return () => {\n      canResetObservableRef.current = true;\n    };\n  }, []);\n\n  const ref = React.useRef({ client, subscription, options });\n  React.useEffect(() => {\n    let shouldResubscribe = options?.shouldResubscribe;\n    if (typeof shouldResubscribe === \"function\") {\n      shouldResubscribe = !!shouldResubscribe(options!);\n    }\n\n    if (options?.skip) {\n      if (\n        !options?.skip !== !ref.current.options?.skip ||\n        canResetObservableRef.current\n      ) {\n        setResult({\n          loading: false,\n          data: void 0,\n          error: void 0,\n          variables: options?.variables,\n        });\n        setObservable(null);\n        canResetObservableRef.current = false;\n      }\n    } else if (\n      (shouldResubscribe !== false &&\n        (client !== ref.current.client ||\n          subscription !== ref.current.subscription ||\n          options?.fetchPolicy !== ref.current.options?.fetchPolicy ||\n          !options?.skip !== !ref.current.options?.skip ||\n          !equal(options?.variables, ref.current.options?.variables))) ||\n      canResetObservableRef.current\n    ) {\n      setResult({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        variables: options?.variables,\n      });\n      setObservable(\n        client.subscribe({\n          query: subscription,\n          variables: options?.variables,\n          fetchPolicy: options?.fetchPolicy,\n          context: options?.context,\n        })\n      );\n      canResetObservableRef.current = false;\n    }\n\n    Object.assign(ref.current, { client, subscription, options });\n  }, [client, subscription, options, canResetObservableRef.current]);\n\n  React.useEffect(() => {\n    if (!observable) {\n      return;\n    }\n\n    let subscriptionStopped = false;\n    const subscription = observable.subscribe({\n      next(fetchResult) {\n        if (subscriptionStopped) {\n          return;\n        }\n\n        const result = {\n          loading: false,\n          // TODO: fetchResult.data can be null but SubscriptionResult.data\n          // expects TData | undefined only\n          data: fetchResult.data!,\n          error: void 0,\n          variables: options?.variables,\n        };\n        setResult(result);\n\n        if (ref.current.options?.onData) {\n          ref.current.options.onData({\n            client,\n            data: result,\n          });\n        } else if (ref.current.options?.onSubscriptionData) {\n          ref.current.options.onSubscriptionData({\n            client,\n            subscriptionData: result,\n          });\n        }\n      },\n      error(error) {\n        if (!subscriptionStopped) {\n          setResult({\n            loading: false,\n            data: void 0,\n            error,\n            variables: options?.variables,\n          });\n          ref.current.options?.onError?.(error);\n        }\n      },\n      complete() {\n        if (!subscriptionStopped) {\n          if (ref.current.options?.onComplete) {\n            ref.current.options.onComplete();\n          } else if (ref.current.options?.onSubscriptionComplete) {\n            ref.current.options.onSubscriptionComplete();\n          }\n        }\n      },\n    });\n\n    return () => {\n      // immediately stop receiving subscription values, but do not unsubscribe\n      // until after a short delay in case another useSubscription hook is\n      // reusing the same underlying observable and is about to subscribe\n      subscriptionStopped = true;\n      setTimeout(() => {\n        subscription.unsubscribe();\n      });\n    };\n  }, [observable]);\n\n  return result;\n}\n", "import * as React from \"react\";\nimport type { ReactiveVar } from \"../../core/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  return useSyncExternalStore(\n    React.useCallback(\n      (update) => {\n        // By reusing the same onNext function in the nested call to\n        // rv.onNextChange(onNext), we can keep using the initial clean-up function\n        // returned by rv.onNextChange(function onNext(v){...}), without having to\n        // register the new clean-up function (returned by the nested\n        // rv.onNextChange(onNext)) with yet another callback.\n        return rv.onNextChange(function onNext() {\n          update();\n          rv.onNextChange(onNext);\n        });\n      },\n      [rv]\n    ),\n    rv,\n    rv\n  );\n}\n", "import * as React from \"react\";\nimport { equal } from \"@wry/equality\";\n\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { mergeDeepArray } from \"../../utilities/index.js\";\nimport type {\n  Cache,\n  Reference,\n  StoreObject,\n  MissingTree,\n} from \"../../cache/index.js\";\n\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport type { OperationVariables } from \"../../core/index.js\";\nimport type { NoInfer } from \"../types/types.js\";\n\nexport interface UseFragmentOptions<TData, TVars>\n  extends Omit<\n      Cache.DiffOptions<NoInfer<TData>, NoInfer<TVars>>,\n      \"id\" | \"query\" | \"optimistic\" | \"previousResult\" | \"returnPartialData\"\n    >,\n    Omit<\n      Cache.ReadFragmentOptions<TData, TVars>,\n      \"id\" | \"variables\" | \"returnPartialData\"\n    > {\n  from: StoreObject | Reference | string;\n  // Override this field to make it optional (default: true).\n  optimistic?: boolean;\n}\n\nexport type UseFragmentResult<TData> =\n  | {\n      data: TData;\n      complete: true;\n      missing?: never;\n    }\n  | {\n      data: DeepPartial<TData>;\n      complete: false;\n      missing?: MissingTree;\n    };\n\nexport function useFragment<TData = any, TVars = OperationVariables>(\n  options: UseFragmentOptions<TData, TVars>\n): UseFragmentResult<TData> {\n  const { cache } = useApolloClient();\n\n  const { fragment, fragmentName, from, optimistic = true, ...rest } = options;\n\n  const diffOptions: Cache.DiffOptions<TData, TVars> = {\n    ...rest,\n    returnPartialData: true,\n    id: typeof from === \"string\" ? from : cache.identify(from),\n    query: cache[\"getFragmentDoc\"](fragment, fragmentName),\n    optimistic,\n  };\n\n  const resultRef = React.useRef<UseFragmentResult<TData>>();\n  let latestDiff = cache.diff<TData>(diffOptions);\n\n  // Used for both getSnapshot and getServerSnapshot\n  const getSnapshot = () => {\n    const latestDiffToResult = diffToResult(latestDiff);\n    return resultRef.current &&\n      equal(resultRef.current.data, latestDiffToResult.data)\n      ? resultRef.current\n      : (resultRef.current = latestDiffToResult);\n  };\n\n  return useSyncExternalStore(\n    (forceUpdate) => {\n      let lastTimeout = 0;\n      const unsubcribe = cache.watch({\n        ...diffOptions,\n        immediate: true,\n        callback(diff) {\n          if (!equal(diff, latestDiff)) {\n            resultRef.current = diffToResult((latestDiff = diff));\n            lastTimeout = setTimeout(forceUpdate) as any;\n          }\n        },\n      });\n      return () => {\n        unsubcribe();\n        clearTimeout(lastTimeout);\n      };\n    },\n    getSnapshot,\n    getSnapshot\n  );\n}\n\nfunction diffToResult<TData>(\n  diff: Cache.DiffResult<TData>\n): UseFragmentResult<TData> {\n  const result = {\n    data: diff.result!,\n    complete: !!diff.complete,\n  } as UseFragmentResult<TData>;\n\n  if (diff.missing) {\n    result.missing = mergeDeepArray(diff.missing.map((error) => error.missing));\n  }\n\n  return result;\n}\n", "import * as React from \"react\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n  FetchMoreQueryOptions,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { ApolloError, NetworkStatus } from \"../../core/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport { isNonEmptyArray } from \"../../utilities/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport type {\n  SuspenseQueryHookOptions,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\nimport { __use, useDeepMemo } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport { skipToken } from \"./constants.js\";\nimport type { SkipToken } from \"./constants.js\";\nimport type { CacheKey } from \"../cache/types.js\";\n\nexport interface UseSuspenseQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  client: ApolloClient<any>;\n  data: TData;\n  error: ApolloError | undefined;\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  networkStatus: NetworkStatus;\n  refetch: RefetchFunction<TData, TVariables>;\n  subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n}\n\nexport type FetchMoreFunction<TData, TVariables extends OperationVariables> = (\n  fetchMoreOptions: FetchMoreQueryOptions<TVariables, TData> & {\n    updateQuery?: (\n      previousQueryResult: TData,\n      options: {\n        fetchMoreResult: TData;\n        variables: TVariables;\n      }\n    ) => TData;\n  }\n) => Promise<ApolloQueryResult<TData>>;\n\nexport type RefetchFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"refetch\"];\n\nexport type SubscribeToMoreFunction<\n  TData,\n  TVariables extends OperationVariables,\n> = ObservableQueryFields<TData, TVariables>[\"subscribeToMore\"];\n\nexport function useSuspenseQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<SuspenseQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> &\n    TOptions\n): UseSuspenseQueryResult<\n  TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\"\n    ? TOptions[\"returnPartialData\"] extends true\n      ? DeepPartial<TData> | undefined\n      : TData | undefined\n    : TOptions[\"returnPartialData\"] extends true\n    ? TOptions[\"skip\"] extends boolean\n      ? DeepPartial<TData> | undefined\n      : DeepPartial<TData>\n    : TOptions[\"skip\"] extends boolean\n    ? TData | undefined\n    : TData,\n  TVariables\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): UseSuspenseQueryResult<DeepPartial<TData>, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): UseSuspenseQueryResult<DeepPartial<TData> | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?:\n    | SkipToken\n    | SuspenseQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n): UseSuspenseQueryResult<TData | undefined, TVariables>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<SuspenseQueryHookOptions<TData, TVariables>>)\n    | SuspenseQueryHookOptions<TData, TVariables> = Object.create(null)\n): UseSuspenseQueryResult<TData | undefined, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  const [promiseCache, setPromiseCache] = React.useState(\n    () => new Map([[queryRef.key, queryRef.promise]])\n  );\n\n  let promise = promiseCache.get(queryRef.key);\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  if (!promise) {\n    promise = queryRef.promise;\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, promise)\n      );\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo(() => {\n    const error = toApolloError(queryRef.result);\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n\n      setPromiseCache((previousPromiseCache) =>\n        new Map(previousPromiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setPromiseCache((previousPromiseCache) =>\n        new Map(previousPromiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const subscribeToMore: SubscribeToMoreFunction<TData, TVariables> =\n    React.useCallback(\n      (options) => queryRef.observable.subscribeToMore(options),\n      [queryRef]\n    );\n\n  return React.useMemo(() => {\n    return {\n      client,\n      data: result.data,\n      error: toApolloError(result),\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    };\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\nfunction validateOptions(options: WatchQueryOptions) {\n  const { query, fetchPolicy, returnPartialData } = options;\n\n  verifyDocumentType(query, DocumentType.Query);\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n\nexport function toApolloError(result: ApolloQueryResult<any>) {\n  return isNonEmptyArray(result.errors)\n    ? new ApolloError({ graphQLErrors: result.errors })\n    : result.error;\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient<unknown>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | SuspenseQueryHookOptions<TData, TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<TData, TVariables>): WatchQueryOptions<\n  TVariables,\n  TData\n> {\n  return useDeepMemo<WatchQueryOptions<TVariables, TData>>(() => {\n    if (options === skipToken) {\n      return { query, fetchPolicy: \"standby\" };\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n", "import type { DependencyList } from \"react\";\nimport * as React from \"react\";\nimport { equal } from \"@wry/equality\";\n\nexport function useDeepMemo<TValue>(\n  memoFn: () => TValue,\n  deps: DependencyList\n) {\n  const ref = React.useRef<{ deps: DependencyList; value: TValue }>();\n\n  if (!ref.current || !equal(ref.current.deps, deps)) {\n    ref.current = { value: memoFn(), deps };\n  }\n\n  return ref.current.value;\n}\n", "import * as React from \"react\";\nimport { canUseDOM } from \"../../../utilities/index.js\";\n\n// use canUseDOM here instead of canUseLayoutEffect because we want to be able\n// to use useLayoutEffect in our jest tests. useLayoutEffect seems to work fine\n// in useSuspenseQuery tests, but to honor the original comment about the\n// warnings for useSyncExternalStore implementation, canUseLayoutEffect is left\n// alone.\nexport const useIsomorphicLayoutEffect = canUseDOM\n  ? React.useLayoutEffect\n  : React.useEffect;\n", "import { wrapPromiseWithState } from \"../../../utilities/index.js\";\nimport * as React from \"react\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n// Prevent webpack from complaining about our feature detection of the\n// use property of the React namespace, which is expected not\n// to exist when using current stable versions, and that's fine.\nconst useKey = \"use\" as keyof typeof React;\nconst realHook = React[useKey] as Use | undefined;\n\n// This is named with two underscores to allow this hook to evade typical rules of\n// hooks (i.e. it can be used conditionally)\nexport const __use =\n  realHook ||\n  function __use<TValue>(promise: Promise<TValue>) {\n    const statefulPromise = wrapPromiseWithState(promise);\n\n    switch (statefulPromise.status) {\n      case \"pending\":\n        throw statefulPromise;\n      case \"rejected\":\n        throw statefulPromise.reason;\n      case \"fulfilled\":\n        return statefulPromise.value;\n    }\n  };\n", "import { equal } from \"@wry/equality\";\nimport type {\n  ApolloError,\n  ApolloQueryResult,\n  ObservableQuery,\n  OperationVariables,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { isNetworkRequestSettled } from \"../../core/index.js\";\nimport type { ObservableSubscription } from \"../../utilities/index.js\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n} from \"../../utilities/index.js\";\nimport type { CacheKey } from \"./types.js\";\nimport type { useBackgroundQuery, useReadQuery } from \"../hooks/index.js\";\n\ntype Listener<TData> = (promise: Promise<ApolloQueryResult<TData>>) => void;\n\ntype FetchMoreOptions<TData> = Parameters<\n  ObservableQuery<TData>[\"fetchMore\"]\n>[0];\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol();\n/**\n * A `QueryReference` is an opaque object returned by {@link useBackgroundQuery}.\n * A child component reading the `QueryReference` via {@link useReadQuery} will\n * suspend until the promise resolves.\n */\nexport interface QueryReference<TData = unknown> {\n  [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData>;\n}\n\ninterface InternalQueryReferenceOptions {\n  key: CacheKey;\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<TData>(\n  internalQueryRef: InternalQueryReference<TData>\n): QueryReference<TData> {\n  return { [QUERY_REFERENCE_SYMBOL]: internalQueryRef };\n}\n\nexport function unwrapQueryRef<TData>(\n  queryRef: QueryReference<TData>\n): InternalQueryReference<TData> {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"canonizeResults\",\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<TData = unknown> {\n  public result: ApolloQueryResult<TData>;\n  public readonly key: CacheKey;\n  public readonly observable: ObservableQuery<TData>;\n\n  public promiseCache?: Map<CacheKey, Promise<ApolloQueryResult<TData>>>;\n  public promise: Promise<ApolloQueryResult<TData>>;\n\n  private subscription: ObservableSubscription;\n  private listeners = new Set<Listener<TData>>();\n  private autoDisposeTimeoutId: NodeJS.Timeout;\n  private status: \"idle\" | \"loading\" = \"loading\";\n\n  private resolve: ((result: ApolloQueryResult<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n\n  constructor(\n    observable: ObservableQuery<TData>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n    // Don't save this result as last result to prevent delivery of last result\n    // when first subscribing\n    this.result = observable.getCurrentResult(false);\n    this.key = options.key;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    if (\n      isNetworkRequestSettled(this.result.networkStatus) ||\n      (this.result.data &&\n        (!this.result.partial || this.watchQueryOptions.returnPartialData))\n    ) {\n      this.promise = createFulfilledPromise(this.result);\n      this.status = \"idle\";\n    } else {\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      });\n    }\n\n    this.subscription = observable\n      .filter(({ data }) => !equal(data, {}))\n      .subscribe({\n        next: this.handleNext,\n        error: this.handleError,\n      });\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      // Wait before fully disposing in case the app is running in strict mode.\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const {\n      fetchPolicy: currentFetchPolicy,\n      canonizeResults: currentCanonizeResults,\n    } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.silentSetOptions(watchQueryOptions);\n\n      if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {\n        this.result = { ...this.result, ...this.observable.getCurrentResult() };\n        this.promise = createFulfilledPromise(this.result);\n      }\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: FetchMoreOptions<TData>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n    this.onDispose();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(result: ApolloQueryResult<TData>) {\n    switch (this.status) {\n      case \"loading\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n        this.status = \"idle\";\n        this.result = result;\n        this.resolve?.(result);\n        break;\n      }\n      case \"idle\": {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (result.data === this.result.data) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        this.result = result;\n        this.promise = createFulfilledPromise(result);\n        this.deliver(this.promise);\n        break;\n      }\n    }\n  }\n\n  private handleError(error: ApolloError) {\n    this.subscription.unsubscribe();\n    this.subscription = this.observable.resubscribeAfterError(\n      this.handleNext,\n      this.handleError\n    );\n\n    switch (this.status) {\n      case \"loading\": {\n        this.status = \"idle\";\n        this.reject?.(error);\n        break;\n      }\n      case \"idle\": {\n        this.promise = createRejectedPromise(error);\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private deliver(promise: Promise<ApolloQueryResult<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(returnedPromise: Promise<ApolloQueryResult<TData>>) {\n    this.status = \"loading\";\n\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then((result) => {\n        if (this.status === \"loading\") {\n          this.status = \"idle\";\n          this.result = result;\n          this.resolve?.(result);\n        }\n      })\n      .catch(() => {});\n\n    return returnedPromise;\n  }\n}\n", "import { Trie } from \"@wry/trie\";\nimport type { ObservableQuery } from \"../../core/index.js\";\nimport { canUseWeakMap } from \"../../utilities/index.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>(\n    canUseWeakMap\n  );\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = Object.create(null)) {\n    this.options = options;\n  }\n\n  getQueryRef<TData = any>(\n    cacheKey: CacheKey,\n    createObservable: () => ObservableQuery<TData>\n  ) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        key: cacheKey,\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current as InternalQueryReference<TData>;\n  }\n}\n", "import type { SuspenseCacheOptions } from \"./index.js\";\nimport { SuspenseCache } from \"./SuspenseCache.js\";\nimport type { ApolloClient } from \"../../core/ApolloClient.js\";\n\ndeclare module \"../../core/ApolloClient.js\" {\n  interface DefaultOptions {\n    react?: {\n      suspense?: Readonly<SuspenseCacheOptions>;\n    };\n  }\n}\n\nconst suspenseCacheSymbol = Symbol.for(\"apollo.suspenseCache\");\n\nexport function getSuspenseCache(\n  client: ApolloClient<object> & {\n    [suspenseCacheSymbol]?: SuspenseCache;\n  }\n) {\n  if (!client[suspenseCacheSymbol]) {\n    client[suspenseCacheSymbol] = new SuspenseCache(\n      client.defaultOptions.react?.suspense\n    );\n  }\n\n  return client[suspenseCacheSymbol];\n}\n", "export const skipToken = Symbol.for(\"apollo.skipToken\");\nexport type SkipToken = typeof skipToken;\n", "import * as React from \"react\";\nimport type {\n  DocumentNode,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"../../core/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { wrapQueryRef } from \"../cache/QueryReference.js\";\nimport type { QueryReference } from \"../cache/QueryReference.js\";\nimport type { BackgroundQueryHookOptions, NoInfer } from \"../types/types.js\";\nimport { __use } from \"./internal/index.js\";\nimport { getSuspenseCache } from \"../cache/index.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\nimport type { FetchMoreFunction, RefetchFunction } from \"./useSuspenseQuery.js\";\nimport { canonicalStringify } from \"../../cache/index.js\";\nimport type { DeepPartial } from \"../../utilities/index.js\";\nimport type { CacheKey } from \"../cache/types.js\";\nimport type { SkipToken } from \"./constants.js\";\n\nexport type UseBackgroundQueryResult<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  fetchMore: FetchMoreFunction<TData, TVariables>;\n  refetch: RefetchFunction<TData, TVariables>;\n};\n\ntype BackgroundQueryHookOptionsNoInfer<\n  TData,\n  TVariables extends OperationVariables,\n> = BackgroundQueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>;\n\nexport function useBackgroundQuery<\n  TData,\n  TVariables extends OperationVariables,\n  TOptions extends Omit<BackgroundQueryHookOptions<TData>, \"variables\">,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & TOptions\n): [\n  (\n    | QueryReference<\n        TOptions[\"errorPolicy\"] extends \"ignore\" | \"all\"\n          ? TOptions[\"returnPartialData\"] extends true\n            ? DeepPartial<TData> | undefined\n            : TData | undefined\n          : TOptions[\"returnPartialData\"] extends true\n          ? DeepPartial<TData>\n          : TData\n      >\n    | (TOptions[\"skip\"] extends boolean ? undefined : never)\n  ),\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<DeepPartial<TData> | undefined>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryReference<TData | undefined>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    returnPartialData: true;\n  }\n): [\n  QueryReference<DeepPartial<TData>>,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n    skip: boolean;\n  }\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [QueryReference<TData>, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, UseBackgroundQueryResult<TData, TVariables>];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (BackgroundQueryHookOptionsNoInfer<TData, TVariables> & {\n        returnPartialData: true;\n      })\n): [\n  QueryReference<DeepPartial<TData>> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | BackgroundQueryHookOptionsNoInfer<TData, TVariables>\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken &\n        Partial<BackgroundQueryHookOptionsNoInfer<TData, TVariables>>)\n    | BackgroundQueryHookOptionsNoInfer<TData, TVariables> = Object.create(null)\n): [\n  QueryReference<TData> | undefined,\n  UseBackgroundQueryResult<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  const [promiseCache, setPromiseCache] = React.useState(\n    () => new Map([[queryRef.key, queryRef.promise]])\n  );\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    promiseCache.set(queryRef.key, promise);\n  }\n\n  React.useEffect(() => queryRef.retain(), [queryRef]);\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setPromiseCache((promiseCache) =>\n        new Map(promiseCache).set(queryRef.key, queryRef.promise)\n      );\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  queryRef.promiseCache = promiseCache;\n\n  const wrappedQueryRef = React.useMemo(\n    () => wrapQueryRef(queryRef),\n    [queryRef]\n  );\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    { fetchMore, refetch },\n  ];\n}\n", "import * as React from \"react\";\nimport { unwrapQueryRef } from \"../cache/QueryReference.js\";\nimport type { QueryReference } from \"../cache/QueryReference.js\";\nimport { __use } from \"./internal/index.js\";\nimport { toApolloError } from \"./useSuspenseQuery.js\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport function useReadQuery<TData>(queryRef: QueryReference<TData>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n  invariant(\n    internalQueryRef.promiseCache,\n    \"It appears that `useReadQuery` was used outside of `useBackgroundQuery`. \" +\n      \"`useReadQuery` is only supported for use with `useBackgroundQuery`. \" +\n      \"Please ensure you are passing the `queryRef` returned from `useBackgroundQuery`.\"\n  );\n\n  const { promiseCache, key } = internalQueryRef;\n\n  if (!promiseCache.has(key)) {\n    promiseCache.set(key, internalQueryRef.promise);\n  }\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          internalQueryRef.promiseCache!.set(internalQueryRef.key, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef]\n    ),\n    () => promiseCache.get(key)!,\n    () => promiseCache.get(key)!\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      networkStatus: result.networkStatus,\n      error: toApolloError(result),\n    };\n  }, [result]);\n}\n"],
  "mappings": "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",
  "names": ["err", "ApolloError", "operationName", "print", "_a", "version", "_b", "_c", "parseError", "HttpLink", "hasOwnProperty", "maybe", "Slot", "hasOwnProperty", "dep", "dep", "hasOwnProperty", "cache", "ApolloCache", "cache", "Cache", "MissingFieldError", "EntityStore", "from", "CacheGroup", "EntityStore", "Root", "Layer", "Stump", "ObjectCanon", "StoreReader", "result", "_a", "cache", "caches", "from", "d", "Policies", "existing", "incoming", "supertypeSet", "from", "StoreWriter", "cache", "_a", "dataId", "context", "value", "selectionSet", "from", "InMemoryCache", "_a", "FragmentRegistry", "NetworkStatus", "hasOwnProperty", "ObservableQuery", "_a", "cache", "info", "LocalState", "cache", "execute", "_a", "node", "cache", "QueryInfo", "diff", "hasOwnProperty", "QueryManager", "cache", "defaultOptions", "hasClientExports", "diff", "DELETE", "result", "variables", "sourcesWithInfo", "_a", "networkStatus", "data", "ApolloClient", "cache", "defaultOptions", "result", "normalize", "React", "React", "React", "React", "React", "React", "React", "DocumentType", "hasOwnProperty", "InternalState", "result", "defaultOptions", "eagerMethods", "key", "execute", "options", "React", "execute", "_a", "options", "mutation", "client", "React", "_a", "_b", "subscription", "result", "React", "React", "cache", "from", "React", "React", "React", "React", "realHook", "__use", "InternalQueryReference", "SuspenseCache", "promise", "promiseCache", "options", "variables", "_a", "React", "options", "promise", "promiseCache", "variables", "React", "promise"]
}
